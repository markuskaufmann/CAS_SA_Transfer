[[section-concepts]]
== Querschnittliche Konzepte

[role="arc42help"]
****
.Content
This section describes overall, principal regulations and solution ideas that are relevant in multiple parts (= cross-cutting) of your system.
Such concepts are often related to multiple building blocks.
They can include many different topics, such as

* models, especially domain models
* architecture or design patterns
* rules for using specific technology
* principal, often technical decisions of an overarching (= cross-cutting) nature
* implementation rules


.Motivation
Concepts form the basis for _conceptual integrity_ (consistency, homogeneity) of the architecture. 
Thus, they are an important contribution to achieve inner qualities of your system.

Some of these concepts cannot be assigned to individual building blocks, e.g. security or safety. 


.Form
The form can be varied:

* concept papers with any kind of structure
* cross-cutting model excerpts or scenarios using notations of the architecture views
* sample implementations, especially for technical concepts
* reference to typical usage of standard frameworks (e.g. using Hibernate for object/relational mapping)

.Structure
A potential (but not mandatory) structure for this section could be:

* Domain concepts
* User Experience concepts (UX)
* Safety and security concepts
* Architecture and design patterns
* "Under-the-hood"
* development concepts
* operational concepts

Note: it might be difficult to assign individual concepts to one specific topic
on this list.

image::08-Crosscutting-Concepts-Structure-EN.png["Possible topics for crosscutting concepts"]


.Further Information

See https://docs.arc42.org/section-8/[Concepts] in the arc42 documentation.
****

****
Von Dokchess
Die verschiedenen Systemteile tauschen schachspezifische Daten aus. Hierzu zählen vor allem die Situation auf dem Brett (Stellung), sowie gegnerische und eigene Züge. Als Aufruf- und Rückgabeparameter finden in allen Modulen dieselben Klassen Verwendung.

An dieser Stelle finden Sie einen groben Überblick über diese Datenstrukturen und deren Abhängigkeiten untereinander. Details sind in der Quelltextdokumentation (javadoc) enthalten. Die Klassen und Aufzählungstypen (enums) befinden sich im Paket de.dokchess.allgemein.

Eine Schachfigur ist gekennzeichnet durch Farbe (schwarz oder weiß) und Art (König, Dame, …). Im Domänenmodell von DokChess weiß eine Figur nicht, wo sie steht. Die Klasse ist unveränderlich (immutable) wie alle anderen im Domänenmodell auch.

Eine Figur hat eine Farbe und eine Art

Bild: Eine Figur hat eine Farbe (z.B. weiß) und eine Art (z.B. Bauer)

Das Schachbrett besteht aus 8 x 8 Feldern die in 8 Reihen (1-8) und 8 Linien (a-h) angeordnet sind. Die Klasse Feld beschreibt ein ebensolches. Da ein Feld maximal von einer Figur besetzt sein kann, reicht für die Angabe eines Zuges, von wo nach wo gezogen wird. Einzige Ausnahme bildet die Umwandlung eines Bauern auf der gegnerischen Grundlinie, da der Spieler selbst entscheidet, in welche Figur er umwandelt (in der Regel, aber nicht zwingend, eine Dame). Rochadezüge werden als Königszüge über zwei Felder in die entsprechende Richtung repräsentiert.

Ein Zug geht von einem Feld zu einem Feld

Bild: Ein Zug geht von einem Feld zu einem Feld

Die Klasse Stellung stellt die aktuelle Situation auf dem Brett dar. Vor allem sind das die Figuren auf dem Brett, das intern als zweidimensionales Array (8 x 8) implementiert ist. Falls ein Feld unbesetzt ist, steht null im Array. Zur Komplettierung der Spielsituation gehört die Information, wer am Zug ist, ob noch Rochaden möglich sind und ob en passant geschlagen werden kann.

****
=== Domänenmodell

Die domänenspezifische Logik von Physio Connect soll mittels eines Domänenmodells implementiert. Das Domänenmodell wurde mit der Hilfe einer Domänenexpertin ausgearbeitet und verfeinert. Bei zusätzlichen Erweiterungen / Anpassungen soll wenn möglich weitere Domänenexperten hinzugezogen werden.

Die Aufteilung der Elemente und die Vorgehensweise bei der Entwicklungen basiert auf __Domain Driven Design (DDD)__. 

Elemente, welche sowohl eine eindeutige ID als auch einene Lebenszyklus besitzen, wurden als Entities definiert. Die zugehörigen Staten der Lebenszyklen sind als Enumeratoren definiert. Elemente mit zusätzlichen Informationen wurden als Value Object definiert.

Repositories und Services wurden nicht modelliert und sollen während der Implementationsphase kontinuierlich erarbeitet werden.

Um das Messaging zu entlasten und ein einfacheres Aufteilen der Stories zu ermöglichen wurde entschieden, Aggregate klein zu halten. So wurde das Initiale Hauptaggregat __Gesamttherapie__ in die unten Aufgeführten Aggregate aufgeteilt. Einige daraus entstandenen Aggregate Roots besitzen nur banale Lebenszyklen. Diese banalen Lebenszyklen wurden nicht modelliert. Informationen zum Initialen Domänenmodell sind im git Repository vorhanden.

plantuml::domain_model/not_generated_gesamttherapie.puml[format=svg]

**Aggregat: GesamtTherapie**

__Definition vom Glossar: Als Gesamttherapie wird eine zusammenhängende Serie von Therapie-Sessions bezeichnet, welche von einem Patienten durchgeführt werden. Eine Gesamttherapie kann von mehreren Wochen bis zu mehreren Jahren dauern. Gesamttherapien werden nach deren vollständiger Absolvierung als abgeschlossen markiert. Patienten können an mehreren Gesamttherapien teilnehmen, im Normalfall jedoch nicht zeitgleich.__

Im Normallfall wird eine Gesamttherapie von einem __hauptTherapeut__ geleitet. Falls ein Patient die Gesamttherapie selbst verwaltet bleibt das Attribut leer.

In vielen Fällen werden Gesamttherapien im Rahmen von Verordnungen erstellt und durchgeführt. Da dies keinen Einfluss auf unsere Applikation hat wurde dies nicht im Modell abgebildet. Eine zukünftige Erweiterung wird aber nicht ausgeschlossen.

Um Typen von Gesamttherapien zu unterscheiden und Filterfunktionen zu ermöglichen wurde der TherapieTyp im Modell abgebildet. __Eigenständige__ Therapien werden vom Patienten selbst verwaltet. Die anderen Typen wurden im Glossar definiert.

[options="header"]
|===
| Diagram | Status | Beschreibung
.6+a| plantuml::additional_diagrams/gesamttherapie_lifecycle.puml[format=svg]
| Entwurf 
| Die Gesamttherapie wurde erstellt aber noch nicht alle Benötigten Daten erfasst.

| WartenAufPatient 
| Eine Einladung wurde an den oder die Patient:in gesendet. Sobald dieser oder diese der Therapie beigetreten ist, wechselt der Status auf Bereit.

| Bereit
| Alle benötigten Daten wurden erfasst und der oder die Patient:in wurde zugewiesen.

| Gestartet
| Mindestens eine Therapiesession wurde ausgeführt.

| Unterbrochen
| Die Gesamttherapie wird für eine längere Zeit unterbrochen. Unvorhergesehene Ereignisse wie die Hospitalisierung des Patienten können Grund für einen Unterbruch sein. Kürze Pausen wie Ferien gelten nicht als Unterbruch.

| Abgebrochen
| Die Gesamttherapie wurde beendet, bevor die geplanten Therapiesessions durchgeführt wurden. Ein Abbruch wird explizit von einem oder einer Therapeut:in gemacht und kann nicht direkt aus den Daten (z.B. offene Therapiesessions) gelesen werden.

|
| Abgeschlossen
| Alle geplanten Therapiesessions wurden durchgeführt und der Patient entlassen. Das Abschliessen einer Gesamttherapie wird explizit von einem oder einer Therapeut:in gemacht und kann nicht direkt aus den Daten gelesen werden.

|
| Archiviert
| Gesamttherapie muss nicht mehr direkt Verfügbar sein und wird bei den meisten Requests rausgefiltert. Eventuell können die Daten in eine __Cold Storage__ verlagert werden.

|===

**Aggregat: TherapieSession**

__Definition vom Glossar: Als Therapie-Session bezeichnet man eine einzelne Therapieeinheit / -sitzung, welche von einem Patienten durchgeführt wird. Diese kann von einem Physiotherapeuten geleitet oder selbst ausgeführt werden.__

Therapie-Sessionen werden hauptsächlich als Kollektionen von Übungen verwendet. Zusätzlich werden Rückmeldungen der Patienten auf die Therapie Session (nicht die einzelnen Übungen) gespeichert und der Fortschritt im Lebenszyklus abgebildet.


plantuml::additional_diagrams/therapiesession_lifecycle.puml[format=svg]

[options="header"]
|===
| Status | Beschreibung

| Erstellt 
| Die Therapie Sessionen wurde erstellt, wurde noch nicht freigegeben zur Ausführung.

| Nachtraeglich Erfasst
| Die Therapie Sessionen wurde zu Dokumentationszwecken erfasst, nachdem diese Bereits vom Patienten durchgeführt wurde. Nachträglich erfasste Therapie Sessionen enthalten keine Patienten Messdaten.

| Startbereit
| Die Therapie Session kann vom Patienten ausgeführt werden.

| Uebersprungen
| Die Therapie Session wurde nicht vom Patienten durchgeführt. Grund dafür kann verpassen des Zeitfensters oder explizites Überspringen durch den Patienten sein.

| Gestartet
| Die Therapie Session wird zu diesem Zeitpunkt vom Patienten durchgeführt.

| Unterbrochen
| Therapie Session wurde vom Patienten unterbrochen.

| Abgebrochen
| Therapie Session wurde vom Patienten abgebrochen.

| Abgeschlossen
| Alle Therapie Übungen wurden abgearbeitet und die benötigten Rückmeldungen ausgefüllt. Wichtig: Therapie Sessionen gelten auch als abgeschlossen, wenn Therapie Übungen übersprungen oder abgebrochen wurden.

|===

plantuml::domain_model/not_generated_therapieuebung.puml[format=svg]

**Aggregat: TherapieUebung**

__Definition vom Glossar: Therapieübungen werden von Patienten während einzelner Therapie Sessionen ausgeführt. Therapieübungen basieren auf Übungsdefinitionen und enthalten exakte Angaben zur Ausführung inklusive Zeitangaben, Serien und Repetitionen. Zusätzlich sind Therapieübungen einem Patienten und einer Therapie zugeordnet und besitzen einen Lebenszyklus.__

Die Abbildung der Messdaten wurde absichtlich Abstrakt gehalten. Wie unterschiedliche Messdaten auswertbar und erweiterbar implementiert werden können muss zu einem späteren Zeitpunkt definiert werden.

In den Therapieübungs Durchführungen wird angegeben, wie viele Repetitionen, Serien oder für welche Dauer eine Übung durchgeführt werden soll und wieoft diese effektiv durchgeführt wurde.

Der Lebenszyklus einer Therapieübung ist sehr Ähnlich wie der von Therapie Sessionen. Der einzige Unterschied ist, dass darauf verzichtet wurde, den Status "Starbereit" zu verwenden. Dies würde zu unnötig komplexen Abhängigkeiten zwischen Übungen führen, welche weder den Entwicklern und Entwicklerinnen noch den Endusern einen Mehrwert erbringen würden.

plantuml::additional_diagrams/therapieuebung_lifecycle.puml[format=svg]

Alle Therapieübungen besitzen eine Übungsbeschreibung, deren Format vom Module __Übungskatalog__ vorgegeben sind. Übugnsbeschreibungen können für Thearpieübungen modifiziert werden, indem von einer Vorlage eine abgeänderte Version der Übungsbeschreibung erstellt wird. So können die Therapeuten Übungen auf Patientenbedürfnisse zuschneiden.

plantuml::domain_model/domain_BC_TherapieContext_UebungsKatalog.puml[format=svg]


**PatientenRueckmeldungen**

Rückmeldungen sind zentral für eine erfolgreiche Physiotherapie. Anhand von Rückmeldungen werden Therapien kontinuierlich angepasst und verbessert.

Die gewünschten Rückmeldungen varieren zwischen Patienten stark. Für Schmerzpatienten werden so zum Beispiel Rückmeldungen für den verspürten Schmerz eingeholt, während bei einer Rehabilitation darauf geschaut wird, dass Patienten körperlich optimal ausgelastet sind.

Patienten Rückmeldungen basieren auf einem Rückmeldungs Typ. Gesundheitseinrichtungen sammeln Rückmeldungen sowohl in standardisierten Formen wie international annerkannte Schmerzskalen als auch mittels individuell definierten Fragen. Aus diesem Grund müssen Rückmeldungstypen abstrakt und einfach erweiterbar implementiert werden.

Um eine bidirektionale Kommunikation zu ermöglichen können Therapeuten und Therapeutinnen wiederum auf Rückmeldungen antworten. Da es nur in Randfällen nötig ist, dass Patienten wiederum auf Therapeutenkommentare antworten, wird dies vom Domänenmodell nicht unterstützt und die Komplexität so verringert.


**UebungsKollektion**

plantuml::domain_model/domain_BC_TherapieContext_UebungsKollektion.puml[format=svg]

Übungskollektionen sind unabhängig von Gesamttherapien und sind eine unkomplizierte Alternative zu geführten Therapien.

Therepeuten und Therapeutinnen geben Patienten, die Therapien abgeschlossen haben, oft ausgedruckte Unterlagen oder Broschüren mit, in denen einige Übungen enthalten sind. Übungskollektionen sollen diese Funktionalitäten im Domänenmodell abdecken.

Zusätzlich zu Übungen können Beispielsessionen erstellt werden, welche aus mehreren Übungsbeschreibungen bestehen. Beispielsessionen können nicht ausgeführt werden und sammeln somit auch keine Messdaten. Die einzelnen Übungsbeschreibungen sind generisch und enthalten keine Wiederholungen und Serien. Von der Applikationsschicht aus wird es die Möglichkeit geben, aus Übugnssessionen effektive Therapie Sessionen zu erstellen. Dies wird jedoch nicht im Rahmen des Domänenmodells beschrieben.

**Gesamtübersicht**

In den folgenden Diagrammen ist die Gesamtübersicht des Domänenmodells ersichtlich.

[.landscape]
<<<
plantuml::domain_model/domain_BC_TherapieContext_PhysioConnectV2.puml[format=svg]

plantuml::domain_model/domain_BC_TherapieContext.puml[format=svg]

[.portrait]
<<<

=== Hexagonale Architektur

Gemäss ADR-BAC20 soll die Architektur der deploybaren Einheiten den hexagonalen Architekturstil befolgen. In diesem Kapitel werden die einzuhaltenden Richtlinien definiert. In Ausnahmefällen kann von diesem Architekturstiel abgewichen werden, z.B. falls die Komplexität einer Einheit zu niedrig ist, um den Aufwand der Implementation im hexagonalen Stil zu rechtfertigen.

Zusätzlich zu der in der hexagonalen Architektur vorgegebenen Ports und Adapter Architektur sollen die folgenden Designvorschriften eingehalten werden:

* Die Businesslogik soll aufgetrennt werden in eine Applikationslogik Komponente und eine Domänenlogik Komponente.
* Für die Kommunikation mit externen Services soll immer die Ports und Adapter Architektur eingehalten werden.

image::not_generated/hexagon_arch1.png["Hexagonale Architektur"]

https://vaadin.com/blog/ddd-part-3-domain-driven-design-and-the-hexagonal-architecture

==== Adapter Entwurfsmuster

Im Zentrum der Umsetzugn einer hexagonalen Architektur ist das Adapter-Muster. Das Adapter-Muster ist ein Entwurfsmuster, das dazu verwendet wird, die Schnittstellen von bestehenden Klassen oder Objekten an die Anforderungen einer neuen Anwendung anzupassen, ohne dass die ursprünglichen Klassen oder Objekte geändert werden müssen. Es ermöglicht es, die Funktionalität von bestehenden Klassen oder Objekten in neue Anwendungen zu integrieren, indem es eine neue Schnittstelle bereitstellt, die mit der neuen Anwendung kompatibel ist. In der hexagonalen Architektur wird das "Target Interface" als Port bezeichnet. Das Pattern besteht aus den folgenden Hauptkomponenten:

* Target / Port
* Adapter
* Adaptee

Als einfaches Beispiel kann die Kommunikation mit der Datenbank genommen werden. Eine Klasse benutzt das Interface __PersistUserPort__ um Benutzer zu persistieren. Die Klasse __DbBridge__ existiert bereits, um Benutzer in die MongoDB abzuspeichern. Da die Klasse __DbBridge__ inkompatibel mit dem Interface __PersistUserPort__ ist und nicht angepasst werden soll wird der *Adapter* __DbPersistenceAdapter__ implementiert, welcher das *Target* Interface __PersistUserPort__ implementiert und den *Adaptee* __DbBridge__ verwendet.

plantuml::additional_diagrams/adapter_pattern.puml[format=svg]

*Anleitung zur Implementation des Adapter Patterns in Java:*

https://www.baeldung.com/java-adapter-pattern

*Anleitung zur Implementation des Adapter Patterns in TypeScript:*

https://sbcode.net/typescript/adapter/

==== Treibende / Getriebene Seite

Hexagonale Architekturen werden in eine treibende linke Seite und eine getriebene rechte Seite aufgeteilt. Die folgende Abbildung ist ein generisches Beispiel einer hexagonalen Architektur und bezieht sich nicht auf das __Physio Connect__ System. Die Seiten bestehen jeweils aus Akteuren, Adaptern und Ports. Komponenten innerhalb des Hexagons werden von den Treibenden Adaptern aufgerufen und lösen so Use Cases aus. Treibende Adapter werden von den Komponenten innerhalb des Hexagons aufgerufen und kommunizieren mit getriebenen Akteuren wie Datenbanken.

image::not_generated/hexagon_detail.webp["Hexagonale Architektur"]

https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/

Ports befinden sich immer innerhalb des Hexagons. Treibende Adapter werden innerhalb des Hexagons implementiert, getriebene Adapter ausserhalb. Da es keine Definition von Layern in der hexagonalen Architektur gibt wird im Rahmen von Physio Connect die folgende Aufteilung verwendet:

*Innerhalb des Hexagons*

* Domänenlayer
* Applikationslayer

*Ausserhalb des Hexagons*

* Infrastrukturlayer
* Externe Komponenten

Die Ports werden hauptsächlich vom Applikationslayer zur Verfügung gestellt, können aber auch direkt vom Domänenlayer stammen. 

Das Beispiel eines Adapter Patterns, welches früher in diesem Kapitel aufgeführt wurde, kann durch eine treibenden Seite und einer Abgrenzung des Hexagons folgendermassen erweitert werden, um alle Qualifikationen einer hexagonalen Architektur einzuhalten.

plantuml::additional_diagrams/hexagon_adapter_pattern.puml[format=svg]

Die wichtigsten Komponenten vom Physio Connect System wurde bereits im Kapitel [*Link Bausteinsicht*] als treibende und getriebene Adapter markiert.

**Treibende Seite**

Folgend sind die häufigsten Akteure und Adapter der Treibenden Seite aufgeführt. Die Definitionen wurden absichtlich abstrakt gehalten, sodass diese auf mehrere Komponenten zutreffen können.

|===

|Akteuer|Adapter|Zweck

|Therapeut:in via Therapie Manager
|API Controller
|Produktive Verwendung von Physio Connect

|Patient:in via Therapie Manager
|API Controller
|Produktive Verwendung von Physio Connect

|Mobile Patientenapp
|API Controller
|Senden der Ausführungsdaten

|Testcases
|API Controller
|Qualitätssicherung

|===

*Mögliche zukünftige Erweiterungen*

|===

|Akteuer|Adapter|Zweck

|Message Queue
|Unbekannt
|Effektive, asynchrone und verlustfreie Abarbeitung von Requests

|Unbekannt
|gRPC Komponente
|Effizientere alternative zu HTTPS

|Dokumentationssoftware
|Unbekannt
|Automatische importierung der Therapiedaten

|===

**Getriebene Seite**

|===

|Adapter|Akteur|Zweck

|Ausführungspersistierungsadapter
|Ausführungsdatenbank
|Verwaltung von Ausführungsdaten

|Therapiepersistierungsadapter
|Therapiedatenbank
|Verwaltung von Therapiedaten

|Mehrere
|Mobile Patientenapp
|Senden von Benachrichtigungen (Therapiedaten, Termine, Rückmeldungen)

|Übungskatalogsadapter
|Übungskatalog
|Beziehen und verwalten von Übungen

|Benutzerverwaltungsadapter
|Benutzerverwaltung
|Authentifizierung, Autorisierung und verwaltung von Benutzern

|===

*Mögliche zukünftige Erweiterungen*

|===

|Adapter|Akteuer|Zweck

|Unbekannt
|Message Queue
|Senden von asynchronen Requests

|Unbekannt
|Patienten Dossier
|Synchronisierung der Patientendaten

|Unbekannt
|Versicherungsschnittstellen
|Senden von relevanten Patientendaten zu Prämienzwecken

|===
