[[section-design-decisions]]
== Architekturentscheidungen

In diesem Kapitel werden alle relevanten Architekturentscheidungen in Form von __Architectural Decision Records (ADRs)__ gemäss https://www.iso.org/standard/50508.html[ISO 42010] definiert. +
Die Entscheidungen sind jeweils thematisch gruppiert, damit sie besser auffindbar sind.

Das Format der Entscheidungen basiert auf dem folgenden Template:

[cols="2,6"]
|===
|**ID**|ADR-[Kategorie]-[Nummer]
|**Anliegen (Concern)**|Anliegen, welches die Grundlage für die Entscheidung darstellt. Formuliert als Fragestellung.
|**Kontext**|Beschreibung der Ausgangslage, um die Relevanz des Anliegens hervorzuheben.
|**Alternativen**
a|
Auflistung der möglichen Alternativen, inkl. deren Vor- und Nachteile.

* [Option 1]
** Beschreibung
** Vorteile
** Nachteile
* [Option 2]
** ...
* [Option 3]
** ...

|**Entscheidung**|Resultat der Entscheidungsfindung bzw. welche der Alternativen eingesetzt wird.
|**Begründung**
a|

* Weshalb wurde Alternative x ausgewählt?
* Beschreibung der eventuellen Konsequenzen (positiv oder negativ), welche beim Einsatz der Alternative x speziell zu beachten sind

|**Follow-up Entscheidungen**|Auflistung der benötigten Entscheidungen, welche aus dieser Entscheidung resultieren und zusätzlich getroffen werden müssen.
|===

=== Security

[cols="2,6"]
|===
|**ID**|ADR-SEC-10
|**Anliegen (Concern)**|Wie wird ein Systemkonsument sicher authentifiziert?
|**Kontext**|Sowohl die bereitgestellte API als auch die Webapplikation (SPA, PWA) von PhysioConnect darf lediglich von Konsumenten (Benutzer oder Systeme) verwendet werden, welche in der Benutzerverwaltung als gültige Benutzer registriert sind. Bei jedem Kommunikationsvorgang muss daher sichergestellt werden, dass die Identität der konsumierenden Partei erfolgreich verifiziert werden konnte.
|**Alternativen**
a|
**Voraussetzungen**

__Allgemein__

Das System "Benutzerverwaltung" gibt bereits die folgenden Rahmenbedingungen vor:

* Als Identity Provider wird https://www.keycloak.org/[Keycloak] verwendet
* Keycloak unterstützt Multi-factor authentication
1. Passwort des Benutzers
2. One-time password via https://googleauthenticator.net/[Google Authenticator] oder https://freeotp.github.io/[FreeOTP]

Nachfolgend werden die kompatiblen Alternativen gelistet.

**A1) HTTP basic authentication** +
Authentifizierung mittels vordefiniertem Username und Passwort. Die Credentials werden mit Base64 transformiert und mit jedem Request als Teil des HTTP Headers mitgegeben. +

__Vorteile:__

* Einfache Implementation +
(Encoding von Username & Passwort mit Base64)
* Einfache Übertragung via HTTP Header
* Keine komplexen Handshake- / Callback-Login-Mechanismen notwendig

__Nachteile:__

* Sollte nicht ohne HTTPS / SSL / TLS verwendet werden
* Anfällig für Hijacking- und Man-in-the-middle-Attacken wenn unverschlüsselte Verbindung
* Grössere Angriffsfläche, da Username / Passwort mit jedem Request quasi als Klartext (Base64) mitgesendet werden
* Passwort wird eventuell im Browsercache abgelegt, was CSRF-Attacken begünstigt
* Im Falle eines erfolgreichen Angriffs sind die Benutzer-Credentials (Username & Passwort) in den Händen des Angreifers, was (je nach internen Rollen und Berechtigungen des betroffenen Benutzers) zu einer immensen Verletzlichkeit des Gesamtsystems führen kann

**A2) API Key** +
Authentifizierung mittels generiertem API Key. Letzterer wird mit jedem Request als Teil des HTTP Headers mitgegeben. +

__Vorteile:__

* Einfache Implementation
* Einfache Übertragung via HTTP Header
* Keine komplexen Handshake- / Callback-Login-Mechanismen notwendig
* Bequemer, da API Keys invalidieren und neu generieren kann, ohne das Passwort eines Benutzeraccounts zu ändern
* Im Falle einer Kompromittierung ist die Angriffsfläche auf die API beschränkt, nicht auf den gesamten Benutzeraccount
* Es können unterschiedliche Keys pro Benutzeraccount, Umgebung und Access Scope generiert werden (z.B. DEV / PROD Key mit Read / Write Access)

__Nachteile:__

* Sollte nicht ohne HTTPS / SSL / TLS verwendet werden
* Anfällig für Hijacking- und Man-in-the-middle-Attacken wenn unverschlüsselte Verbindung
* Grössere Angriffsfläche, da der API Key mit jedem Request als Klartext mitgesendet wird
* Im Falle eines erfolgreichen Angriffs ist die gesamte API kompromittiert

**A3) OAuth 2.0 mit OpenID Connect und Bearer Token (JWT)** +
Authentifizierung via https://oauth.net/2/[OAuth 2.0]-Flow mit https://openid.net/connect/[OpenID Connect]. OAuth 2.0 ist ein etabliertes Autorisierungsframework und bietet eine Spezifikation für die Implementation von Autorisierungsprotokollen und -flows. OpenID Connect basiert auf dem OAuth 2.0-Framework und ist ein Standard, welcher speziell auf die Benutzerauthentifikation ausgerichtet ist.

__Vorteile:__

* Etabliertes Framework - es gibt zahlreiche Online-Dokumentationen und Guides
* State-of-the-art bezüglich der Absicherung von APIs
* Ausgestellte Bearer Tokens (JWT) können seitens API einfach auf ihre Integrität und Gültigkeit validiert werden
* Tokens können auf feingranulare API Scopes ausgestellt werden, was die Angriffsfläche theoretisch reduziert
* Möglichkeit, zusätzliche Refresh Tokens zu verwenden, welche bei Ablauf eines Access Tokens automatisch einen neuen anfordern
* Unterstützt Single Sign-On (SSO)
* Ausgestellte Bearer Tokens (JWT) können Browser-seitig in einem Cookie abgelegt werden (bzw. Standardverhalten für manche Identity Provider), damit sie nicht alternativ im Local oder Session Storage gespeichert werden müssen
* Unterstützung verschiedener Client-Typen (z.B. Device, SPA / Public client)

__Nachteile:__

* Ist nicht immer ganz einfach zu implementieren
* Kann bei falscher Implementation und / oder Konfiguration zu https://www.rfc-editor.org/rfc/rfc6819#section-4[Sicherheitslücken] führen

**A4) SAML** +
Authentifizierung via https://auth0.com/blog/how-saml-authentication-works/[SAML]. Security Assertion Markup Language (SAML) ist - nebst OpenID Connect - ein weiterer Standard, welcher auf die Benutzerauthentifikation ausgerichtet ist.

__Vorteile:__

* Etablierter Standard
* Unterstützt Single Sign-On (SSO)

__Nachteile:__

* Alter Standard: Die neuste Version des Standards besteht bereits seit 2005
** nicht einfach, aktuelle Web- (SPA) und Mobileapplikationen mit SAML abzusichern
** OpenID Connect wurde unter anderem dafür entworfen, SAML abzulösen
* Verwendet XML anstelle von JSON Web Tokens (JWT) als Übertragungsformat
** erhöhter Ressourcenbedarf (Netzwerk & Memory) im Vergleich zu JWT
** bei der Implementation muss auf die bestehenden https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html[XML-Angriffsvektoren] Acht gegeben werden
* API Scopes werden nicht out-of-the-box unterstützt

|**Entscheidung**
a|
* A3) OAuth 2.0 mit OpenID Connect und Bearer Token (JWT)
* Multi-factor authentication (MFA)

|**Begründung**|Die Authentifizierung mit OAuth 2.0 und OpenID Connect ist eine etablierte und (zurzeit) sichere Methode zur Verifikation der Identität eines Systemkonsumenten. In der direkten Gegenüberstellung mit den restlichen Alternativen ist OAuth & OpenID Connect spezifisch darauf ausgelegt, den Authentifizierungsworkflow zwischen Frontend (SPA, PWA) und Backend (API) so sicher wie möglich zu gestalten. +
Vorsicht ist jedoch bei der Implementation und Konfiguration geboten - wie bereits als Nachteil dieser Variante erfasst, kann eine falsche Implementation und / oder Konfiguration zu Sicherheitslücken führen. Dies kann jedoch theoretisch bei jeder Alternative der Fall sein. +
OAuth 2.0 & OpenID Connect wird zudem von allen gängigen (Social) Identity Providern einwandfrei unterstützt.

Des Weiteren ist der supplementäre Einsatz von Multi-factor authentication (MFA) ein relevanter Bestandteil aktueller Authentifizierungsmechanismen und wird daher als notwendig angesehen. Hierbei wird auf die unterstützten MFA-Faktoren von Keycloak sowie den angebotenen Social Identity Providern (ADR-SEC-11) zurückgegriffen.
|**Follow-up Entscheidungen**
a|
* **ADR-SEC-11** +
Mit welchen Social Identity Providern kann sich ein Systembenutzer authentifizieren?

|===

[cols="2,6"]
|===
|**ID**|ADR-SEC-11
|**Anliegen (Concern)**|Mit welchen Social Identity Providern kann sich ein Systembenutzer authentifizieren?
|**Kontext**
a|Social Identity Providers wie Google, Microsoft oder Apple ermöglichen die Authentifizierung eines Benutzers über bereits existierende (Social Media) Accounts. Auf diese Weise werden Benutzerinformationen und Credentials (Username & Passwort) lediglich an einem zentralen Ort (nämlich beim betroffenen Social Identity Provider) verwaltet und nicht bei PhysioConnect redundant gehalten. +
Zudem ist der Login-Prozess über Social Identity Providers meist intuitiver, da die Benutzer meist denselben Account mit verschiedenen Services verknüpfen (z.B. Google-Account) und sich daher überall mit denselben Credentials und über dieselbe Login-Maske und Multi-factor authentication (MFA) authentifizieren können.
|**Alternativen**
a|
**Voraussetzungen**

__Allgemein__

Das System "Benutzerverwaltung" gibt bereits die folgenden Rahmenbedingungen vor:

* Als Identity Provider wird https://www.keycloak.org/[Keycloak] verwendet
* Keycloak unterstützt __identity provider federation__, sprich die Delegation der Authentifizierung zu verknüpften, externen (Social) Identity Providern. Voraussetzung für die Anbindung ist die Kompatibilität zu OAuth 2.0 & OpenID Connect.

__ADR-SEC-10__

* OAuth 2.0 & OpenID Connect wird unterstützt
* Multi-factor authentication (MFA) wird unterstützt

Nachfolgend werden die kompatiblen Alternativen gelistet.

**A1) Kein Social Identity Provider** +
PhysioConnect bietet keine Authentifizierung via Social Identity Provider an.

__Vorteile:__

* Kein Zusatzaufwand seitens PhysioConnect-Identity Provider (ADR-SEC-11) für die Einbindung externer Identity Providers
* Vollständige Kontrolle über alle Benutzeraccounts, da alle Informationen innerhalb des Systemkontexts abgelegt sind
* Keine zusätzlichen Datenschutz- / Privacy Concerns, da die Benutzerdaten nicht ausserhalb des Systemkontexts verwendet werden können
* Bei der Verwendung von Social Identity Providers wird das potenzielle Schadensausmass im Falle eines Account-Hijackings vergrössert. Beispielsweise kann sich ein Angreifer bei der Übernahme eines Google Accounts auf allen Webseiten anmelden, welche sich mittels Verwendung des Google Accounts authentifizieren 

__Nachteile:__

* Redundante Datenhaltung, da ein Grossteil der Benutzer bereits einen Account bei einem (oder mehreren) Social Identity Providers besitzt
* Eigene Login-Maske und Multi-factor authentication (MFA)-Prozess für alle Benutzer
* Benutzer müssen sich mit dedizierten Credentials (Username & Passwort) anmelden

**A2) Google** +
Authentifizierung über Google.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Google-Ökosystem befinden oder mehrheitlich Google-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller Android User inkludiert.

__Nachteile:__ +
-

**A3) Microsoft** +
Authentifizierung über Microsoft.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Microsoft-Ökosystem befinden oder mehrheitlich Microsoft-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller Windows User inkludiert.

__Nachteile:__ +
-

**A4) Apple** +
Authentifizierung über Apple.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Apple-Ökosystem befinden oder mehrheitlich Apple-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller iOS & macOS User inkludiert.

__Nachteile:__ +
-

|**Entscheidung**
a|
Verwendung von

* A1) Google
* A2) Microsoft
* A3) Apple

Die Möglichkeit der Authentifizierung über die obigen Social Identity Provider soll in erster Linie den Patienten (= externen Benutzeraccounts) zur Verfügung stehen. Die Benutzeraccounts von Physiotherapeuten, Vorgesetzten und weiteren kundenseitig internen Benutzern werden im Rahmen des Systems "Benutzerverwaltung" mit der bestehenden Identity & Access Management-Lösung des Kunden (z.B. Active Directory) synchronisiert. +
Eine Ausnahme bilden Kunden, welche ihre internen Benutzer bereits via Microsoft Accounts (z.B. via Office 365) authentifizieren.
|**Begründung**|Die Verwendung von Social Identity Providers bietet eine hohe Flexibilität bei relativ geringem Integrationsaufwand. Mit der Kombination aus Google, Microsoft und Apple sollte das Angebot an Social Identity Providern eine klare Mehrheit der zukünftigen Benutzer abdecken. +
Zudem kann auf diese Weise eine redundante Datenhaltung von Benutzeraccounts verhindert werden, da ein Grossteil der zukünftigen Benutzer bereits einen Account bei einem (oder mehreren) Social Identity Providers besitzt.

**Hinweis:** +
Diese Entscheidung führt zu entsprechenden Änderungen in PhysioConnect (Webapplikation, API) sowie dem System "Benutzerverwaltung" (Konfiguration der Social Identity Providers in Keycloak).
|**Follow-up Entscheidungen**|-
|===

=== Messaging

[cols="2,6"]
|===
|**ID**|ADR-MES-10
|**Anliegen (Concern)**|Wie wird das Messaging innerhalb von Physio Connect umgesetzt?

|**Kontext**
|Sowohl Requests von Physiotherapeuten als auch Patienten werden vom PhysioConnect System gehandhabt. Zu Peak Zeiten kann es sich dabei um eine hohe Last an Daten handeln. Da gemäss *link zu ADR Backend* PhysioConnect aus mehreren Containern bestehen wird, soll überprüft werden, ob eine Messaging Komponente eingesetzt werden soll und falls ja, welche.

|**Alternativen**
a|

**HTTP/HTTPS**

__Vorteile:__

* Einfache Implementierung
* Know-How weit verbreitet
* Von vielen verschiedenen Libraries unterstützt

__Nachteile:__

* Weniger effizient als einige Alternativen


**Message Queues** (RabbitMQ, Kafka)

__Vorteile:__

* Kann je nach Implementierungsart Requests effizient abarbeiten (Trade Off mit Traceablility)
* Gruppierung von Gruppen nach Themen
* Skalierbare Messaging Komponente
* Sender muss nicht darauf Warten, bis die Message verarbeitet wurde
* Bei Ausfall der Datenbank könnten die Daten kurzfristig in der Queue als Messages persistiert sein bis die Datenbank wieder erreichbar ist.

__Nachteile:__

* Benötigt Messaging Container
* Erhöht Komplexität der Lösung

**gRPC**

__Vorteile:__

* Sehr Performant
* Ermöglicht bi-direktionale Kommunikation

__Nachteile:__

* Mehraufwand für die Implementation
* Weniger breite Unterstützung als andere Ansätze
* Weniger Know-How vorhanden

|**Entscheidung**|HTTP / HTTPS
|**Begründung**
a|

* Implementation mit HTTPS hat die geringste Komplexität 
* Time to Market ist in einem ersten Schritt wichtiger als die Performanz
* Für eine geringe Anzahl Benutzer wird es einfach sein, eine gute Performanz mittels Skalierung zu erreichen
* Es ist einfacher, Bottlenecks zu erkennen und zu optimieren, wenn das System bereits produktiv im Einsatz ist

Es soll jedoch bei Design und Implementation darauf geachtet werden, dass in Zukunft die gezielte Verwendung von gRPC oder einer Messaging Queue möglich gehalten werden muss.

|**Follow-up Entscheidungen**|-
|===

=== Frontend Architektur

==== Plattformen

[cols="2,6"]
|===
|**ID**|ADR-FRO-10
|**Anliegen (Concern)**|Welche Plattformen sollen unterstützt werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden dieses Frontend hauptsächlich für die Planung und Auswertung von Therapien.

|**Alternativen**
a|

**Browser (exklusive Mobile-Browser)**

__Vorteile:__

* Applikation kann von einer sehr hohen Anzahl Geräten verwendet werden
* Eine Implementation deckt die Anwendung für verschiedene Betriebssysteme ab

__Nachteile:__

* Erhöhter Implementationsaufwand und Testaufwand durch Unterstützung verschiedener Browser

**Mobile-Browser**

__Vorteile:__

* Es wird keine Workstation benötigt, um die Applikation zu verwenden
* Relativ Zusatzaufwand falls Browser Applikation bereits entwickelt wird (gleiche Codebase)

__Nachteile:__

* Alle UI Elemente müssen so Umgesetzt werden, dass sie auf einem kleinen Screen funktionieren
* Erhöhter Testaufwand
* Mehr und schwerer zu Reproduzierende Fehler durch zusätzliche / veraltete Betriebssysteme und mobilen Browser

**Android App**

__Vorteile (im Vergleich zu nur Mobile Browser):__

* Erhöhte Benutzerfreundlichkeit für Android Anwender durch
** App auf dem Homescreen
** Bessere Unterstützung von gerätespezifischen Funktionalitäten wie Kamera

__Nachteile:__

* Es muss eine Implementationsart verwendet werden, mit welcher eine App aus der gleichen Codebase wie die Web Applikation generiert werden kann.

**iOS App**

__Vorteile:__

* Erhöhte Benutzerfreundlichkeit für iOS Anwender durch
** App auf dem Homescreen
** Bessere Unterstützung von gerätespezifischen Funktionalitäten wie Kamera

__Nachteile:__

* Es muss eine Implementationsart verwendet werden, mit welcher eine App aus der gleichen Codebase wie die Web Applikation generiert werden kann.

**Desktop Applikation**

__Vorteile:__

* Bessere Performance als Web Applications
* Bietet Offline Funktionalitäten an

__Nachteile:__

* Systemabhängig

|**Entscheidung**
|Muss: Browser & Mobile Browser. 

Kann: Android App & iOS App

|**Begründung**
a|
Da wir keinen Einfluss auf das System unserer Kunden haben schliesst dies eine Desktop Applikation aus. Web Applikationen genügen ausserdem für die für unser System benötigte Performance.

Da Physiotherapeuten oft nicht im Büro sind und trotzdem Zugriff auf die Therapiedaten haben müssen, müssen mobile Browser unterstützt werden.

Es wurden bereits Funktionalitäten gewünscht wie Fotografieren und Videoaufnahmen für Übungsbeschreibungen. Dies hätte eine höhere Usability in Apps als im Browser. Da der Implementationsaufwand minimal gehalten werden sollte und nur eine Codebase verwendet werden muss, wird dieser Entscheid bei der Analyse der zu verwendenden Technologien getroffen.

|**Follow-up Entscheidungen**|
ADR-FRO-11
|===

==== Frontend Architekturstil

[cols="2,6"]
|===
|**ID**|ADR-FRO-11
|**Anliegen (Concern)**|Welcher Architekturstiel soll für das PhysioConnect Frontend verwendet werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden dieses Frontend hauptsächlich für die Planung und Auswertung von Therapien. Mobile Browser müssen unterstützt werden.

|**Alternativen**
a|

**Single Page Application**

__Vorteile:__

* Hohe Responsiveness, da alles zum Start geladen wird
* Server muss nicht bei jedem Klick des Users requests entgegennehmen
* Rechenleistung der Clients kann verwendet werden

__Nachteile:__

* Häufige Reloads können zu einer hohen Datenlast führen
* Schlechte Suchmaschinenoptimierung
* Ausführung von Funktionalitäten direkt im Browser des Clients kann zu Sicherheitslücken führen

**Server Side Rendering**

__Vorteile:__

* Suchmaschinenoptimierung möglich
* Sichere Ausführung von Funktionen auf dem Server

__Nachteile:__

* Relativ tiefe Responsiveness
* Alle rechenleistungen müssen von uns zur Verfügung gestellt werden

**Static Side Generation**

__Vorteile:__

* Sehr schnell

__Nachteile:__

* Inhalt wird vorgeneriert und kann dementsprechend nicht  zu Echtzeit angepasst werden

|**Entscheidung**
|Single Page Application

|**Begründung**
a|
Wir haben uns für SPAs entschieden, da mit einer SPA sowohl unsere funktionalen Anforderungen als auch die Qualitätsattribute umgesetzt werden können. Die für SPAs typische Nachteile wie schlechte Suchmaschinenoptimierung sind für uns nur begrenzt relevant.

Mit Static Side Generation können nicht alle benötigten Funktionalitäten für Physio Connect umgesetzt werden.

Mit Server Side Rendering wäre es sehr Aufwendig, die Gewünschten Usability umzusetzen.


|**Follow-up Entscheidungen**|
ADR-FRO-12
|===

==== Frontend Technologie

[cols="2,6"]
|===
|**ID**|ADR-FRO-12
|**Anliegen (Concern)**|Mit welcher Technologie soll die Single Page Application Umgesetzt werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden dieses Frontend hauptsächlich für die Planung und Auswertung von Therapien. Mobile Browser müssen unterstützt werden. Es wurde bestimmt, dass eine SPA verwendet wird.

|**Alternativen**
a|

*Flutter*

__Vorteile:__

* Cross Plattform Applikation von einer Codebase

__Nachteile:__

* Kaum Know-How zu Dart Programming Language vorhanden
* Support für Web Applikationen schlechter verglichen mit den anderen Alternativen

*React*

__Vorteile:__

* Viel Know-How in der Community vorhanden
* Kompatibel mit vielen Libraries
* Sehr hohe Zufriedenheit in der State of JS Umfrage https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/

__Nachteile:__

* Relativ komplex zum erlernen

*Angular*

__Vorteile:__

* Viel Know-How in der Community vorhanden
* Hohe Unterstützung für Typescript

__Nachteile:__

* Komplex zum erlernen
* Tiefe Zufriedenheit in State of JS https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/

*Vue*

__Vorteile:__

* Einfacher zu erlernen als die Alternativen
* Relativ hohe Zufriedenheit in der State of JS Umfrage https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/

__Nachteile:__

* Relativ kleine Community
* Verglichen wenig angebotene Features

|**Entscheidung**|React
|**Begründung**
a|
Der Hauptvorteil von Flutter, nämlich die Unterstützung von Geräten ausserhalb von Desktops und Apps, hat bei uns keine Priorität.

Für Angular gab es in den letzten Jahren viele schlechte Rückmeldungen.

VueJS und React sind beide für unser Projekt geeignet, React scheint jedoch eine aktivere Community zu besitzen und hat einen höhere Anzahl an direkt unterstützten Features, was den Implementationsaufwand senken sollte. Aus diesem Grund haben wir uns für React entschieden.

|**Follow-up Entscheidungen**|
ADR-FRO-13: 
Da das Framework nun bekannt ist kann entschieden werden, ob eine App unterstützt werden soll oder nicht.

ADR-FRO-14: 
Sollen Micro Frontends verwendet werden, um die SPA umzusetzen?

|===

==== Mobile Unterstützung

[cols="2,6"]
|===
|**ID**|ADR-FRO-13
|**Anliegen (Concern)**|Soll eine iOS und Android App aus der React App generiert werden? Falls ja, mit welcher Technologie?

|**Kontext**
|Es wurde entschieden, dass bei geringem Umsetzungsaufwand eine App für iOS und Android gemacht werden sollte. Zusätzlich wurde bestimmt, dass React zum Umsetzen der Web Applikation verwendet wird und dass nur eine Codebase existieren darf.

|**Alternativen**
a|

*Keine App*

__Vorteile:__

* Kein Entwicklungsaufwand

__Nachteile:__

* Keine App auf dem Homescreen
* Gerätespezifische Funktionen werden schlechter unterstützt
* Seite normalerweise nicht im Fullscreen

*Progressive Web App (PWA)*

__Vorteile:__

* Apps müssen nicht über einen Store veröffentlicht werden
* Apps besitzen immer die gleiche Version wie der Server. Falls mehrere Systeme im Einsatz sind (self Hosted vom Kunden), passt das App automatisch mit der Kundenversion überein

* Relativ geringer Umsetzungsaufwand
* Bietet eingeschränkte Offline Funktionalitäten an
* Da es sich weiterhin um ein Browserapp handelt und nicht auf die native Funktionalitäten zugreift muss nicht mit einer vielzahl von Devices getestet werden

__Nachteile:__

* Features nicht so ausgereift wie bei Native Apps
* iOS Safari bietet weniger Funktionalitäten an als Android

*React Native*

__Vorteile:__

* Bietet Offline Funktionalitäten an
* Verwendet Device native Funktionalitäten
* Relativ geringer Supportaufwand da Reactspezifische Lösung

__Nachteile:__

* Unterstützung von Native Funktionalitäten führt zu erhöhtem Testaufwand
* Es muss bestimmt werden, welche OS unterstützt werden. Diese sollten auch aktiv getestet werden.

*Cordova*

__Vorteile:__

* Bietet Offline Funktionalitäten an
* Verwendet Device native Funktionalitäten


__Nachteile:__

* Relativ hoher Supportaufwand da Cordova nicht nur für React entwickelt wird
* Unterstützung von Native Funktionalitäten führt zu erhöhtem Testaufwand
* Es muss bestimmt werden, welche OS unterstützt werden. Diese sollten auch aktiv getestet werden.


|**Entscheidung**|PWA
|**Begründung**
a|Es wurde PWA gewählt, da dies einen relativ geringen Umsetzungsaufwand benötigt und gleichzeitig alle Usabilty Requirements erfüllt. Der Vorteil von Native apps kann mit dem Physio Connect Vorteil kaum ausgenutzt werden, da hauptsächlich die Kamera verwendet wird und ansonsten nur Begrenzt Offline Content benötigt wird. Der Usability Vorteil, eine PWA umzusetzen, übertrifft den geringeren Implementationsaufwand für die Alternative "keine App".

|**Follow-up Entscheidungen**|
|===