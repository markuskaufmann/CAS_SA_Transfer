[[section-design-decisions]]
== Architekturentscheidungen

In diesem Kapitel werden alle relevanten Architekturentscheidungen in Form von __Architectural Decision Records (ADRs)__ gemäss https://www.iso.org/standard/50508.html[ISO 42010] definiert. +
Die Entscheidungen sind jeweils thematisch gruppiert, damit sie besser auffindbar sind.

Das Format der Entscheidungen basiert auf dem folgenden Template:

[cols="2,6"]
|===
|**ID**|ADR-[Kategorie]-[Nummer]
|**Anliegen (Concern)**|Anliegen, welches die Grundlage für die Entscheidung darstellt. Formuliert als Fragestellung.
|**Kontext**|Beschreibung der Ausgangslage, um die Relevanz des Anliegens hervorzuheben.
|**Alternativen**
a|
Auflistung der möglichen Alternativen, inkl. deren Vor- und Nachteile.

* [Option 1]
** Beschreibung
** Vorteile
** Nachteile
* [Option 2]
** ...
* [Option 3]
** ...

|**Entscheidung**|Resultat der Entscheidungsfindung bzw. welche der Alternativen eingesetzt wird.
|**Begründung**
a|

* Weshalb wurde Alternative x ausgewählt?
* Beschreibung der eventuellen Konsequenzen (positiv oder negativ), welche beim Einsatz der Alternative x speziell zu beachten sind

|**Follow-up Entscheidungen**|Auflistung der benötigten Entscheidungen, welche aus dieser Entscheidung resultieren und zusätzlich getroffen werden müssen.
|===

=== Security

[cols="2,6"]
|===
|**ID**|ADR-SEC-10
|**Anliegen (Concern)**|Wie wird ein Systemkonsument sicher authentifiziert?
|**Kontext**|Sowohl die bereitgestellte API als auch die Webapplikation (SPA, PWA) von PhysioConnect darf lediglich von Konsumenten (Benutzer oder Systeme) verwendet werden, welche in der Benutzerverwaltung als gültige Benutzer registriert sind. Bei jedem Kommunikationsvorgang muss daher sichergestellt werden, dass die Identität der konsumierenden Partei erfolgreich verifiziert werden konnte.
|**Alternativen**
a|
**Voraussetzungen**

__Allgemein__

Das System "Benutzerverwaltung" gibt bereits die folgenden Rahmenbedingungen vor:

* Als Identity Provider wird https://www.keycloak.org/[Keycloak] verwendet
* Keycloak unterstützt Multi-factor authentication
1. Passwort des Benutzers
2. One-time password via https://googleauthenticator.net/[Google Authenticator] oder https://freeotp.github.io/[FreeOTP]

Nachfolgend werden die kompatiblen Alternativen gelistet.

**A1) HTTP basic authentication** +
Authentifizierung mittels vordefiniertem Username und Passwort. Die Credentials werden mit Base64 transformiert und mit jedem Request als Teil des HTTP Headers mitgegeben. +

__Vorteile:__

* Einfache Implementation +
(Encoding von Username & Passwort mit Base64)
* Einfache Übertragung via HTTP Header
* Keine komplexen Handshake- / Callback-Login-Mechanismen notwendig

__Nachteile:__

* Sollte nicht ohne HTTPS / SSL / TLS verwendet werden
* Anfällig für Hijacking- und Man-in-the-middle-Attacken wenn unverschlüsselte Verbindung
* Grössere Angriffsfläche, da Username / Passwort mit jedem Request quasi als Klartext (Base64) mitgesendet werden
* Passwort wird eventuell im Browsercache abgelegt, was CSRF-Attacken begünstigt
* Im Falle eines erfolgreichen Angriffs sind die Benutzer-Credentials (Username & Passwort) in den Händen des Angreifers, was (je nach internen Rollen und Berechtigungen des betroffenen Benutzers) zu einer immensen Verletzlichkeit des Gesamtsystems führen kann

**A2) API Key** +
Authentifizierung mittels generiertem API Key. Letzterer wird mit jedem Request als Teil des HTTP Headers mitgegeben. +

__Vorteile:__

* Einfache Implementation
* Einfache Übertragung via HTTP Header
* Keine komplexen Handshake- / Callback-Login-Mechanismen notwendig
* Bequemer, da API Keys invalidieren und neu generieren kann, ohne das Passwort eines Benutzeraccounts zu ändern
* Im Falle einer Kompromittierung ist die Angriffsfläche auf die API beschränkt, nicht auf den gesamten Benutzeraccount
* Es können unterschiedliche Keys pro Benutzeraccount, Umgebung und Access Scope generiert werden (z.B. DEV / PROD Key mit Read / Write Access)

__Nachteile:__

* Sollte nicht ohne HTTPS / SSL / TLS verwendet werden
* Anfällig für Hijacking- und Man-in-the-middle-Attacken wenn unverschlüsselte Verbindung
* Grössere Angriffsfläche, da der API Key mit jedem Request als Klartext mitgesendet wird
* Im Falle eines erfolgreichen Angriffs ist die gesamte API kompromittiert

**A3) OAuth 2.0 mit OpenID Connect und Bearer Token (JWT)** +
Authentifizierung via https://oauth.net/2/[OAuth 2.0]-Flow mit https://openid.net/connect/[OpenID Connect]. OAuth 2.0 ist ein etabliertes Autorisierungsframework und bietet eine Spezifikation für die Implementation von Autorisierungsprotokollen und -flows. OpenID Connect basiert auf dem OAuth 2.0-Framework und ist ein Standard, welcher speziell auf die Benutzerauthentifikation ausgerichtet ist.

__Vorteile:__

* Etabliertes Framework - es gibt zahlreiche Online-Dokumentationen und Guides
* State-of-the-art bezüglich der Absicherung von APIs
* Ausgestellte Bearer Tokens (JWT) können seitens API einfach auf ihre Integrität und Gültigkeit validiert werden
* Tokens können auf feingranulare API Scopes ausgestellt werden, was die Angriffsfläche theoretisch reduziert
* Möglichkeit, zusätzliche Refresh Tokens zu verwenden, welche bei Ablauf eines Access Tokens automatisch einen neuen anfordern
* Unterstützt Single Sign-On (SSO)
* Ausgestellte Bearer Tokens (JWT) können Browser-seitig in einem Cookie abgelegt werden (bzw. Standardverhalten für manche Identity Provider), damit sie nicht alternativ im Local oder Session Storage gespeichert werden müssen
* Unterstützung verschiedener Client-Typen (z.B. Device, SPA / Public client)

__Nachteile:__

* Ist nicht immer ganz einfach zu implementieren
* Kann bei falscher Implementation und / oder Konfiguration zu https://www.rfc-editor.org/rfc/rfc6819#section-4[Sicherheitslücken] führen

**A4) SAML** +
Authentifizierung via https://auth0.com/blog/how-saml-authentication-works/[SAML]. Security Assertion Markup Language (SAML) ist - nebst OpenID Connect - ein weiterer Standard, welcher auf die Benutzerauthentifikation ausgerichtet ist.

__Vorteile:__

* Etablierter Standard
* Unterstützt Single Sign-On (SSO)

__Nachteile:__

* Alter Standard: Die neuste Version des Standards besteht bereits seit 2005
** nicht einfach, aktuelle Web- (SPA) und Mobileapplikationen mit SAML abzusichern
** OpenID Connect wurde unter anderem dafür entworfen, SAML abzulösen
* Verwendet XML anstelle von JSON Web Tokens (JWT) als Übertragungsformat
** erhöhter Ressourcenbedarf (Netzwerk & Memory) im Vergleich zu JWT
** bei der Implementation muss auf die bestehenden https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html[XML-Angriffsvektoren] Acht gegeben werden
* API Scopes werden nicht out-of-the-box unterstützt

|**Entscheidung**
a|
* A3) OAuth 2.0 mit OpenID Connect und Bearer Token (JWT)
* Multi-factor authentication (MFA)

|**Begründung**|Die Authentifizierung mit OAuth 2.0 und OpenID Connect ist eine etablierte und (zurzeit) sichere Methode zur Verifikation der Identität eines Systemkonsumenten. In der direkten Gegenüberstellung mit den restlichen Alternativen ist OAuth & OpenID Connect spezifisch darauf ausgelegt, den Authentifizierungsworkflow zwischen Frontend (SPA, PWA) und Backend (API) so sicher wie möglich zu gestalten. +
Vorsicht ist jedoch bei der Implementation und Konfiguration geboten - wie bereits als Nachteil dieser Variante erfasst, kann eine falsche Implementation und / oder Konfiguration zu Sicherheitslücken führen. Dies kann jedoch theoretisch bei jeder Alternative der Fall sein. +
OAuth 2.0 & OpenID Connect wird zudem von allen gängigen (Social) Identity Providern einwandfrei unterstützt.

Des Weiteren ist der supplementäre Einsatz von Multi-factor authentication (MFA) ein relevanter Bestandteil aktueller Authentifizierungsmechanismen und wird daher als notwendig angesehen. Hierbei wird auf die unterstützten MFA-Faktoren von Keycloak sowie den angebotenen Social Identity Providern (ADR-SEC-11) zurückgegriffen.
|**Follow-up Entscheidungen**
a|
* **ADR-SEC-11** +
Mit welchen Social Identity Providern kann sich ein Systembenutzer authentifizieren?

|===

[cols="2,6"]
|===
|**ID**|ADR-SEC-11
|**Anliegen (Concern)**|Mit welchen Social Identity Providern kann sich ein Systembenutzer authentifizieren?
|**Kontext**
a|Social Identity Providers wie Google, Microsoft oder Apple ermöglichen die Authentifizierung eines Benutzers über bereits existierende (Social Media) Accounts. Auf diese Weise werden Benutzerinformationen und Credentials (Username & Passwort) lediglich an einem zentralen Ort (nämlich beim betroffenen Social Identity Provider) verwaltet und nicht bei PhysioConnect redundant gehalten. +
Zudem ist der Login-Prozess über Social Identity Providers meist intuitiver, da die Benutzer meist denselben Account mit verschiedenen Services verknüpfen (z.B. Google-Account) und sich daher überall mit denselben Credentials und über dieselbe Login-Maske und Multi-factor authentication (MFA) authentifizieren können.
|**Alternativen**
a|
**Voraussetzungen**

__Allgemein__

Das System "Benutzerverwaltung" gibt bereits die folgenden Rahmenbedingungen vor:

* Als Identity Provider wird https://www.keycloak.org/[Keycloak] verwendet
* Keycloak unterstützt __identity provider federation__, sprich die Delegation der Authentifizierung zu verknüpften, externen (Social) Identity Providern. Voraussetzung für die Anbindung ist die Kompatibilität zu OAuth 2.0 & OpenID Connect.

__ADR-SEC-10__

* OAuth 2.0 & OpenID Connect wird unterstützt
* Multi-factor authentication (MFA) wird unterstützt

Nachfolgend werden die kompatiblen Alternativen gelistet.

**A1) Kein Social Identity Provider** +
PhysioConnect bietet keine Authentifizierung via Social Identity Provider an.

__Vorteile:__

* Kein Zusatzaufwand seitens PhysioConnect-Identity Provider (ADR-SEC-11) für die Einbindung externer Identity Providers
* Vollständige Kontrolle über alle Benutzeraccounts, da alle Informationen innerhalb des Systemkontexts abgelegt sind
* Keine zusätzlichen Datenschutz- / Privacy Concerns, da die Benutzerdaten nicht ausserhalb des Systemkontexts verwendet werden können
* Bei der Verwendung von Social Identity Providers wird das potenzielle Schadensausmass im Falle eines Account-Hijackings vergrössert. Beispielsweise kann sich ein Angreifer bei der Übernahme eines Google Accounts auf allen Webseiten anmelden, welche sich mittels Verwendung des Google Accounts authentifizieren 

__Nachteile:__

* Redundante Datenhaltung, da ein Grossteil der Benutzer bereits einen Account bei einem (oder mehreren) Social Identity Providers besitzt
* Eigene Login-Maske und Multi-factor authentication (MFA)-Prozess für alle Benutzer
* Benutzer müssen sich mit dedizierten Credentials (Username & Passwort) anmelden

**A2) Google** +
Authentifizierung über Google.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Google-Ökosystem befinden oder mehrheitlich Google-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller Android User inkludiert.

__Nachteile:__ +
-

**A3) Microsoft** +
Authentifizierung über Microsoft.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Microsoft-Ökosystem befinden oder mehrheitlich Microsoft-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller Windows User inkludiert.

__Nachteile:__ +
-

**A4) Apple** +
Authentifizierung über Apple.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Apple-Ökosystem befinden oder mehrheitlich Apple-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller iOS & macOS User inkludiert.

__Nachteile:__ +
-

|**Entscheidung**
a|
Verwendung von

* A1) Google
* A2) Microsoft
* A3) Apple

Die Möglichkeit der Authentifizierung über die obigen Social Identity Provider soll in erster Linie den Patienten (= externen Benutzeraccounts) zur Verfügung stehen. Die Benutzeraccounts von Physiotherapeuten, Vorgesetzten und weiteren kundenseitig internen Benutzern werden im Rahmen des Systems "Benutzerverwaltung" mit der bestehenden Identity & Access Management-Lösung des Kunden (z.B. Active Directory) synchronisiert. +
Eine Ausnahme bilden Kunden, welche ihre internen Benutzer bereits via Microsoft Accounts (z.B. via Office 365) authentifizieren.
|**Begründung**|Die Verwendung von Social Identity Providers bietet eine hohe Flexibilität bei relativ geringem Integrationsaufwand. Mit der Kombination aus Google, Microsoft und Apple sollte das Angebot an Social Identity Providern eine klare Mehrheit der zukünftigen Benutzer abdecken. +
Zudem kann auf diese Weise eine redundante Datenhaltung von Benutzeraccounts verhindert werden, da ein Grossteil der zukünftigen Benutzer bereits einen Account bei einem (oder mehreren) Social Identity Providers besitzt.

**Hinweis:** +
Diese Entscheidung führt zu entsprechenden Änderungen in PhysioConnect (Webapplikation, API) sowie dem System "Benutzerverwaltung" (Konfiguration der Social Identity Providers in Keycloak).
|**Follow-up Entscheidungen**|-
|===

=== Frontend Architektur

==== Plattformen

[cols="2,6"]
|===
|**ID**|ADR-FRO-10
|**Anliegen (Concern)**|Welche Plattformen sollen unterstützt werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden das PhysioConnect-Frontend hauptsächlich für die Planung und Auswertung von Therapien.

|**Alternativen**
a|

**A1) Browser (exklusive Mobile-Browser)**

__Vorteile:__

* Applikation kann von einer sehr hohen Anzahl Geräte verwendet werden
* Eine Implementation deckt die Anwendung für verschiedene Betriebssysteme ab

__Nachteile:__

* Erhöhter Implementationsaufwand und Testaufwand durch Unterstützung verschiedener Browser

**A2) Mobile Browser**

__Vorteile:__

* Es wird keine Workstation benötigt, um die Applikation zu verwenden
* Relativer Zusatzaufwand falls Browser-Applikation bereits entwickelt wird (gleiche Codebase)

__Nachteile:__

* Alle UI-Elemente müssen so umgesetzt werden, dass sie auf unterschiedlichen Bildschirmgrössen funktionieren
* Erhöhter Testaufwand
* Mehr und schwerer zu reproduzierende Fehler durch zusätzliche / veraltete Betriebssysteme und mobile Browser

**A3) Android App**

__Vorteile (im Vergleich zu A2):__

* Erhöhte Benutzerfreundlichkeit für Android-Anwender durch
** App auf dem Homescreen
** Bessere Unterstützung von gerätespezifischen Funktionalitäten wie Kamera

__Nachteile:__

* Es muss eine Implementationsart verwendet werden, mit welcher eine App aus der gleichen Codebase wie die Webapplikation generiert werden kann.

**A4) iOS App**

__Vorteile (im Vergleich zu A2):__

* Erhöhte Benutzerfreundlichkeit für iOS-Anwender durch
** App auf dem Homescreen
** Bessere Unterstützung von gerätespezifischen Funktionalitäten wie Kamera

__Nachteile:__

* Es muss eine Implementationsart verwendet werden, mit welcher eine App aus der gleichen Codebase wie die Webapplikation generiert werden kann.

**A5) Desktop-Applikation**

__Vorteile:__

* Bessere Performance als Webapplikationen
* Bietet Offline-Funktionalitäten an

__Nachteile:__

* Betriebssystemabhängig

|**Entscheidung**
a|
Muss:

* A1) Browser
* A2) Mobile Browser

Kann:
* A3) Android App
* A4) iOS App

|**Begründung**
a|
Da wir keinen Einfluss auf das System unserer Kunden haben, schliesst dies eine Desktop-Applikation aus. Webapplikationen genügen ausserdem für die für unser System benötigte Performance.

Da Physiotherapeuten oft nicht im Büro sind und trotzdem Zugriff auf die Therapiedaten haben müssen, müssen mobile Browser ebenfalls unterstützt werden.

Es wurden bereits Funktionalitäten gewünscht wie die Aufnahme von Fotos und Videos für Übungsbeschreibungen. Dies hätte eine höhere Usability in Mobile Apps als im Browser. Da der Implementationsaufwand minimal gehalten werden sollte und nur eine Codebase verwendet werden muss, wird dieser Entscheid bei der Analyse der zu verwendenden Technologien getroffen.

|**Follow-up Entscheidungen**
a|
* **ADR-FRO-11** +
Welcher Architekturstil soll für das PhysioConnect-Frontend verwendet werden?

|===

==== Architekturstil

[cols="2,6"]
|===
|**ID**|ADR-FRO-11
|**Anliegen (Concern)**|Welcher Architekturstil soll für das PhysioConnect-Frontend verwendet werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden das PhysioConnect-Frontend hauptsächlich für die Planung und Auswertung von Therapien. Mobile Browser müssen unterstützt werden.

|**Alternativen**
a|

**A1) Single Page Application (SPA)**

__Vorteile:__

* Hohe Responsiveness, da alles zum Start geladen wird
* Server muss nicht bei jedem Klick des Users entsprechende Requests entgegennehmen
* Rechenleistung der Clients (bzw. Client Browsers) kann verwendet werden

__Nachteile:__

* Häufige Reloads können zu einer hohen Datenlast führen
* Schlechte Suchmaschinenoptimierung (SEO)
* Ausführung von Funktionalitäten direkt im Browser des Clients kann zu Sicherheitslücken führen

**A2) Server-side Rendering (SSR)**

__Vorteile:__

* Suchmaschinenoptimierung (SEO) möglich
* Sichere Ausführung von Funktionen auf dem Server

__Nachteile:__

* Relativ tiefe Responsiveness
* Alle für eine optimale Rechenleistung erforderlichen Systemressourcen müssen von uns zur Verfügung gestellt werden

**A3) Static Side Generation (SSG)**

__Vorteile:__

* Sehr schnell

__Nachteile:__

* Inhalt wird vorgeneriert und kann dementsprechend nicht in Echtzeit angepasst werden

|**Entscheidung**
|A1) Single Page Application (SPA)

|**Begründung**
a|
Wir haben uns für eine Single Page Application entschieden, da mit einer SPA sowohl unsere funktionalen Anforderungen als auch die Qualitätsattribute umgesetzt werden können. Die für SPAs typischen Nachteile - wie beispielsweise eine schlechte Suchmaschinenoptimierung - sind für uns nur begrenzt relevant.

Mit Static Site Generation können nicht alle benötigten Funktionalitäten für Physio Connect umgesetzt werden.

Mit Server-side Rendering wäre es sehr aufwändig, die gewünschte Usability umzusetzen.

|**Follow-up Entscheidungen**
a|
* **ADR-FRO-12** +
Mit welcher Technologie soll die Single Page Application umgesetzt werden?

|===

==== Frontend-Technologie

[cols="2,6"]
|===
|**ID**|ADR-FRO-12
|**Anliegen (Concern)**|Mit welcher Technologie soll die Single Page Application umgesetzt werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden das PhysioConnect-Frontend hauptsächlich für die Planung und Auswertung von Therapien. Mobile Browser müssen unterstützt werden. Es wurde entschieden, dass eine Single Page Application (SPA) verwendet werden soll.

|**Alternativen**
a|

**A1) Flutter**

__Vorteile:__

* Cross Plattform-Applikation mittels der Verwendung einer gemeinsamen Codebase

__Nachteile:__

* Kaum Know-How zu Dart Programming Language vorhanden
* Support für Webapplikationen ist schlechter (verglichen mit den anderen Alternativen)

**A2) React**

__Vorteile:__

* Viel Know-How in der Community vorhanden
* Kompatibel mit vielen Libraries
* Sehr hohe Zufriedenheit in der https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/[State of JS-Umfrage (2021)]

__Nachteile:__

* Relativ steile Lernkurve

**A3) Angular**

__Vorteile:__

* Viel Know-How in der Community vorhanden
* Hohe Unterstützung für Typescript

__Nachteile:__

* Steile Lernkurve
* Tiefe Zufriedenheit in der https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/[State of JS-Umfrage (2021)]

**A4) Vue.js**

__Vorteile:__

* Einfacher zu erlernen als die Alternativen
* Relativ hohe Zufriedenheit in der https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/[State of JS-Umfrage (2021)]

__Nachteile:__

* Relativ kleine Community
* Vergleichsweise wenig angebotene Features

|**Entscheidung**|A2) React
|**Begründung**
a|
Der Hauptvorteil von Flutter, nämlich die Unterstützung von Geräten ausserhalb von Desktops und Apps, hat bei uns keine Priorität.

Für Angular gab es in den letzten Jahren viele schlechte Rückmeldungen.

Vue.js und React sind beide für unser Projekt geeignet, React scheint jedoch eine aktivere Community zu besitzen und hat eine höhere Anzahl an direkt unterstützten Features, was den Implementationsaufwand senken sollte. Aus diesem Grund haben wir uns für React entschieden.

|**Follow-up Entscheidungen**
a|
* **ADR-FRO-13** +
Soll eine iOS und Android App aus der React App generiert werden? Falls ja, mit welcher Technologie?
* **ADR-FRO-14** +
Sollen Micro Frontends verwendet werden?

|===

==== Mobile Unterstützung

[cols="2,6"]
|===
|**ID**|ADR-FRO-13
|**Anliegen (Concern)**|Soll eine iOS und Android App aus der React App generiert werden? Falls ja, mit welcher Technologie?

|**Kontext**
|Es wurde entschieden, dass bei geringem Umsetzungsaufwand eine App für iOS und Android realisiert werden sollte. Zusätzlich wurde bestimmt, dass React zum Umsetzen der Webapplikation verwendet wird und dass nur eine gemeinsame Codebase existieren darf.

|**Alternativen**
a|

**A1) Keine App**

__Vorteile:__

* Kein Entwicklungsaufwand

__Nachteile:__

* Keine App auf dem Homescreen
* Gerätespezifische Funktionen werden schlechter unterstützt
* Seite normalerweise nicht im Fullscreen

**A2) Progressive Web App (PWA)**

__Vorteile:__

* Apps müssen nicht über einen Store veröffentlicht werden
* Apps besitzen immer die gleiche Version wie der Server. Falls mehrere Systeme im Einsatz sind (self-hosted vom Kunden), passt die App automatisch mit der Kundenversion überein
* Relativ geringer Umsetzungsaufwand
* Bietet eingeschränkte Offline-Funktionalitäten an
* Da es sich weiterhin um ein Browser-App handelt und nicht auf die native Funktionalitäten zugreift, muss nicht mit einer Vielzahl von Devices getestet werden

__Nachteile:__

* Features nicht so ausgereift wie bei Native Apps
* iOS Safari bietet weniger Funktionalitäten an als Android

**A3) React Native**

__Vorteile:__

* Bietet Offline-Funktionalitäten an
* Verwendet Device-native Funktionalitäten
* Relativ geringer Supportaufwand, da React-spezifische Lösung

__Nachteile:__

* Unterstützung von nativen Funktionalitäten führt zu erhöhtem Testaufwand
* Es muss bestimmt werden, welche Betriebssysteme unterstützt werden. Diese sollten auch aktiv getestet werden.

**A4) Cordova**

__Vorteile:__

* Bietet Offline-Funktionalitäten an
* Verwendet Device-native Funktionalitäten

__Nachteile:__

* Relativ hoher Supportaufwand, da Cordova nicht nur für React entwickelt wird
* Unterstützung von nativen Funktionalitäten führt zu erhöhtem Testaufwand
* Es muss bestimmt werden, welche Betriebssysteme unterstützt werden. Diese sollten auch aktiv getestet werden.

|**Entscheidung**|A2) Progressive Web App (PWA)
|**Begründung**
a|Der Entscheid fiel auf die Verwendung einer Progressive Web App, da dies einen relativ geringen Umsetzungsaufwand benötigt und gleichzeitig alle Usabilty Requirements erfüllt. Der Vorteil von Native Apps kann mit dem Physio Connect-Vorteil kaum ausgenutzt werden, da hauptsächlich die Kamera verwendet wird und ansonsten nur begrenzt Offline Content benötigt wird. Der Usability-Vorteil, eine PWA umzusetzen, übertrifft den geringeren Implementationsaufwand für die Alternative __A1) Keine App__.

|**Follow-up Entscheidungen**|
|===

==== Micro Frontends

[cols="2,6"]
|===
|**ID**|ADR-FRO-14
|**Anliegen (Concern)**|Sollen Micro Frontends verwendet werden?

|**Kontext**
|Es wurde entschieden, das PhysioConnect-Frontend mit einer Single Page Application (SPA) umzusetzen. Nun soll entschieden werden, ob für die Umsetzung zusätzlich Micro Frontends verwendet werden sollen.

|**Alternativen**
a|

**A1) Micro Frontends**

__Vorteile:__

* Frontends können einzeln deployed werden
* Frontends können separat entwickelt werden
* Zur Umsetzung der Frontends können verschiedene Frameworks und Programmiersprachen verwendet werden
* Frontends sind einzeln skalierbar

__Nachteile:__

* Erhöhte Komplexität für die Umsetzung
* Frontends müssen miteinander kompatibel gehalten werden

**A2) Keine Micro Frontends**

Umkehrung der Alternative __A1) Micro Frontends__.

|**Entscheidung**|A2) Keine Micro Frontends
|**Begründung**
a|
Die Vorteile von Micro Frontends können in Physio Connect kaum verwendet werden. Um die Komplexität gering zu halten, fiel der schlussendliche Entscheid gegen die Verwendung von Micro Frontends.

|**Follow-up Entscheidungen**|
|===

=== Backend Architektur

==== Architekturstil

[cols="2,6"]
|===
|**ID**|ADR-BAC-10
|**Anliegen (Concern)**|Welche Architekturstile sollen aus Sicht einer deploybaren Einheit eingesetzt werden?
|**Kontext**
a|
Das Backend von PhysioConnect besteht grundsätzlich aus den folgenden High Level-Komponenten:

* API Controllers / Request Handlers für die Entgegennahme und formale Kontrolle der eingehenden Requests
** Kommunikation mit Patienten-App +
(z.B. Übertragung der Messdaten, Start einer Therapie-Session)
** Kommunikation mit PhysioConnect-Webapplikation / -Frontend +
(z.B. Erstellung einer Therapie)
* Businesslogik für die fachliche Verarbeitung der Requests
* https://learn.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer[Anti-corruption layers] für die Kommunikation mit den Systemen "Übungskatalog" und "Benutzerverwaltung"

Diese Entscheidung befasst sich damit, welche Architekturstile für die obigen Komponenten hinsichtlich deren optimalen Kommunikation, Skalier- und Deploybarkeit eingesetzt werden können.
|**Alternativen**
a|
**A1) Monolith**

__Vorteile:__

* Einfachheit: +
Ein Monolith besteht aus einer einzigen, in sich geschlossenen Einheit, welche - verglichen mit verteilten Systemen - leicht zu verstehen ist
* Einfaches Deployment: +
Da es sich bei einem Monolith um eine einzige Einheit handelt, lässt sie sich einfach und atomar deployen

__Nachteile:__

* Eingeschränkte Skalierbarkeit: +
Es kann schwierig sein, einen Monolithen horizontal zu skalieren, da die gesamte Anwendung als eine einzige Einheit deployed werden muss
* Hohe Kopplung: +
Die internen Komponenten eines Monolithen sind meist eng miteinander gekoppelt, was die Änderung, Erweiterung und / oder Wiederverwendung einzelner Komponenten erschwert

**A2) Microservices**

__Vorteile:__

* Skalierbarkeit: +
Microservices können unabhängig voneinander skaliert werden, was wiederum die Skalierbarkeit des Gesamtsystems erhöht
* Wiederverwendbarkeit: +
Microservices sind kleine, unabhängige Funktionseinheiten und können daher in verschiedenen Kontexten wiederverwendet werden
* Erweiterbarkeit: +
Etwaige Modifikationen oder Erweiterungen eines Microservices sind mit geringer Komplexität realisierbar, da sich die darin befindlichen Funktionalitäten nur in dem jeweils betroffenen Microservice befinden und nicht über mehrere Services aufgetrennt sind
* Einfaches Deployment: +
Da es sich bei Microservices um unabhängige Einheiten handelt, ist es relativ einfach, neue Versionen einzelner Microservices zu deployen, ohne den Rest des Systems zu beeinträchtigen
* Lose Kopplung: +
Das Konzept von Microservices ermöglicht eine lose Kopplung zwischen abhängigen Services. Beispielsweise kann sich ein von Service A benötigter Service B innerhalb eines Clusters von gleichwertigen Service B-Instanzen befinden. Service A benötigt keine direkte Kopplung zu einer Service B-Instanz, sondern sendet seine Requests an eine vordefinierte URL. Der Cluster Controller nimmt den Request entgegen, leitet ihn an eine beliebige Service B-Instanz weiter und Letztere verarbeitet den Request und retourniert eine Response.
* Testing: +
Aufgrund der klaren Abgrenzung und losen Kopplung zu anderen Services lassen sich einzelne Microservices einfach testen. Die bestehenden Abhängigkeiten können mittels geringem Aufwand durch entsprechende Mocks ersetzt werden.
* Parallele Entwicklung: +
Aufgrund der klaren funktionalen Abgrenzung und Unabhängigkeit eines Microservices ist es möglich, pendente Entwicklungsarbeiten an mehreren Microservices zu parallelisieren (z.B. indem unterschiedliche Entwicklungsteams an unterschiedlichen Services arbeiten)

__Nachteile:__

* Komplexität: +
Der Aufbau und die Pflege eines Systems, welches aus vielen kleinen, unabhängigen Microservices besteht, kann relativ schnell an Komplexität zunehmen
* Kommunikation zwischen den Services: +
Die Kommunikation zwischen einzelnen Microservices ist komplexer als die Kommunikation innerhalb eines Monoliths. Zudem haben externe Einflüsse wie beispielsweise die Netzwerkverbindung (Latenzzeit, Bandbreite, Auslastung, Durchsatz) einen Einfluss auf die Qualität und Geschwindigkeit der Kommunikation

**A3) Self-contained systems (SCS)**

__Vorteile:__

* Einfachheit: +
SCS sind relativ einfach zu verstehen (verglichen mit verteilten Systemen)
* Erweiterbarkeit: +
Etwaige Modifikationen oder Erweiterungen innerhalb eines SCS sind mit geringer Komplexität realisierbar, da sich die darin befindlichen Funktionalitäten nur in dem jeweils betroffenen SCS befinden und nicht über mehrere Systeme aufgetrennt sind 
* Parallele Entwicklung: +
Aufgrund der klaren funktionalen Abgrenzung und Unabhängigkeit eines SCS ist es möglich, pendente Entwicklungsarbeiten an mehreren SCS zu parallelisieren (z.B. indem unterschiedliche Entwicklungsteams an unterschiedlichen SCS arbeiten)

__Nachteile:__

* Begrenzte Skalierbarkeit: +
Es kann schwierig sein, ein SCS horizontal zu skalieren, da das System jeweils als atomare Einheit deployed werden muss
* Begrenzte Wiederverwendbarkeit: +
SCS sind unabhängige Funktionseinheiten, besitzen jedoch meist einen eigenen Stack aus Frontend, Businesslogik und Persistenz. Daher ist die funktionale Wiederverwendung eines SCS eingeschränkter als bei einzelnen Microservices. Mittels dem Einsatz spezifischer Kommunikationsmechanismen (z.B. API, Event-driven) ist es jedoch möglich, Funktionalitäten eines SCS zur Wiederverwendung bereitzustellen.

**A4) Lambda architecture**

__Vorteile:__

* Skalierbarkeit: +
Lambda-Funktionen können automatisch skaliert werden, um der aktuellen Nachfrage gerecht zu werden
* Kosteneffizienz: +
Bei einer Mehrheit der aktuellen Hyperscaler zahlt man nur für die verbrauchte Rechenzeit, was - vor allem bei fluktuierender Auslastung - kostengünstiger sein kann als der Betrieb eigener Server
* Echtzeitverarbeitung: +
Die Echtzeitverarbeitungskomponente (Stream / Speed Layer) der Lambda-Architektur ermöglicht die sofortige Verarbeitung und Analyse der eingehenden Daten
* Datenverarbeitung: Separation of Concerns: +
Durch die Aufteilung der Datenverarbeitung in einen Stream und Batch Layer lassen sich die jeweiligen Systemverantwortlichkeiten und Funktionalitäten sauber voneinander separarieren

__Nachteile:__

* Komplexität: +
Die grundsätzliche Implementierung einer Lambda-Architektur kann relativ schnell komplex werden, da zwei separate Layer / Systeme für die Datenverarbeitung erforderlich sind (Stream & Batch Layer).
* Infrastruktur- / Vendor-basiert: +
Die Implementierung einer Lambda-Architektur auf Basis von Open Source-Technologien gefolgt von einem Cloud-Deployment kann zu komplexen Fehlersituationen führen, weshalb meist auf angebotene Services der jeweiligen Hyperscaler (Microsoft, Amazon, Google) zurückgegriffen wird. Dabei erhöht man jedoch das Risiko eines Vendor Lock-ins bzw. die Abhängigkeit zum verwendeten Hyperscaler / Vendor.

|**Entscheidung**|A2) Microservices
|**Begründung**|Der Einsatz von Microservices deckt die erhöhte Priorität betreffend den Punkten Wiederverwendbarkeit, Modifizierbarkeit / Erweiterbarkeit und Skalierbarkeit optimal ab. +
Funktionalitäten können optimal auf einzelne Services aufgeteilt und Letztere mit möglichst loser Kopplung entwickelt, betrieben und gewartet werden. Des Weiteren können einzelne Services je nach anfallender Last dynamisch / automatisiert skaliert werden.
|**Follow-up Entscheidungen**|-
|===

[cols="2,6"]
|===
|**ID**|ADR-BAC-20
|**Anliegen (Concern)**|Welcher Architekturstil soll grundlegend innerhalb einer deploybaren Einheit eingesetzt werden?
|**Kontext**
a|Diese Entscheidung befasst sich damit, welcher Architekturstil grundlegend für die interne Struktur (Mikroarchitektur) der einzelnen Backend-Komponenten eingesetzt werden soll. +
Hierbei handelt es sich jedoch nur um den grundlegend zu verwendenden Stil - es ist durchaus legitim und plausibel, dass es aus Sicht einer oder mehrerer Komponenten sinnvoller ist, eine andere interne Struktur zu wählen. Der Einsatz eines komponentenspezifischen Stils sollte jedoch in einem dedizierten ADR konkret begründet werden.
|**Alternativen**
a|
**A1) Layered architecture**

__Vorteile:__

* Separation of Concerns: +
Durch die einzelnen Layers wird eine klare Separation of Concerns geschaffen, was die Verständlichkeit des Codes erhöht
* Wiederverwendbarkeit: +
Da jede Schicht unabhängig entwickelt und getestet werden kann, wird die Wiederverwendbarkeit indirekt erhöht
* Innerhalb eines Layers ist es relativ einfach, bestehende Funktionen zu ändern oder neue hinzuzufügen, ohne den Rest der Anwendung zu beeinträchtigen
* Testing: +
Die einzelnen Layer können isoliert sehr gut getestet werden

__Nachteile:__

* Modifizierbarkeit / Erweiterbarkeit: +
Starre Abhängigkeiten zwischen den einzelnen Layer können zu einer Gesamtstruktur führen, die unflexibel und nur schwer zu modifizieren / erweitern ist
* Hohe Kopplung durch https://devopedia.org/leaky-abstractions[leaky abstraction]: +
Wenn ein Layer seine Implementationsdetails nicht vollständig abstrahiert und abhängige Layer nicht korrekt ohne Kenntnis dieser Details kommunizieren können, wird von einer __leaky abstraction__ gesprochen. Dieser Effekt verletzt die Seperation of Concerns und erhöht somit die Kopplung zwischen den betroffenen Layers.

**A2) Hexagonal architecture (Ports & Adapters)**

__Vorteile:__

* Separation of Concerns: +
Durch die gezielte Trennung der Businesslogik und des "Ports & Adapter-Hexagons" wird eine klare Separation of Concerns geschaffen, was die Verständlichkeit des Codes erhöht
* Testbarkeit: +
Durch die einfache Abstraktion der externen Abhängigkeiten kann die interne Businesslogik einfacher und gezielter getestet werden
* Flexibilität: +
Die Möglichkeit, zwischen verschiedenen Technologien / Adaptern zu wechseln, macht diesen Stil zu einer flexiblen "Plugin-Architektur". Solange derselbe Port für unterschiedliche Adapter verwendet werden kann, können die konkreten Implementierungen ausgetauscht werden, ohne dabei Änderungen in der Businesslogik vorzunehmen.
* Modifizierbarkeit / Erweiterbarkeit: +
Aufgrund der abstrakten Ports kann die Businesslogik ohne Auswirkungen auf die externen Abhängigkeiten geändert werden. Änderungen innerhalb einer externen Abhängigkeit können lediglich mit der entsprechenden Änderung des jeweiligen Adapters nachgeführt werden, ohne die Businesslogik zu beeinflussen. +
Die Erweiterbarkeit ist ebenfalls gegeben, da neue Funktionen durch die Modifizierung der Businesslogik oder durch das Hinzufügen eines neuen Adapters hinzugefügt werden können.

__Nachteile:__

* Komplexität: +
Aufgrund der Trennung von Businesslogik und externen Abhängigkeiten und der diesbezüglich eingesetzten Indirektionen / Abstraktionen (z.B. durch den Einsatz von Interfaces) kann dieser Stil schwierig zu verstehen und daher komplexer und aufwändiger zu implementieren sein - vor allem für Entwickler, welche noch wenig / keine Erfahrung mit dem Stil besitzen

**A3) Clean / Onion architecture**

__Vorteile:__

* Kombination mit Hexagonal Architecture (Ports & Adapters) +
Die Schichten der Clean / Onion Architecture sorgen für eine konkrete Organisation der Businesslogik, dem Inneren des "Ports & Adapter-Hexagons"
* Verwendung von Domain-driven design (DDD) +
Clean / Onion Architecture baut auf einem gegebenen Domänenmodell auf und unterstützt daher die Verwendung von DDD inkl. dessen Layers (Domain, Application, Infrastructure, UI)
* Separation of Concerns: +
Durch die gezielte Trennung der Businesslogik in einzelne Layer wird eine klare Separation of Concerns geschaffen, was die Verständlichkeit des Codes erhöht
* Testbarkeit: +
Durch die einfache Abstraktion der Abhängigkeiten kann die interne Businesslogik eines Layers isoliert und daher einfacher / gezielter getestet werden
* Flexibilität: +
Aus Sicht eines inneren Layers (z.B. Domain) können die äusseren Layer (z.B. Application) problemlos ausgetauscht werden, ohne zu Änderungen im betroffenen Layer zu führen
* Modifizierbarkeit / Erweiterbarkeit: +
Durch die lose und gerichtete Kopplung (äussere Schichten "zeigen" nach innen, nie umgekehrt) lassen sich äussere Layer einfach und ohne grossen Mehraufwand modifizieren. Änderungen am Domain Layer (der "Kern" des Domänenmodells) hingegen dürfen zu abhängigen Anpassungen in den äusseren Layern führen, da sie alle (direkt oder indirekt) von der Domäne abhängig sind. +
Die Erweiterbarkeit ist ebenfalls gegeben, da neue Funktionen durch die Modifizierung der Businesslogik eines Layers hinzugefügt werden können.

__Nachteile:__

* Komplexität: +
Aufgrund der zahlreichen Layers und diesbezüglich eingesetzten Indirektionen / Abstraktionen (z.B. durch den Einsatz von Interfaces) kann dieser Stil schwierig zu verstehen und daher komplexer und aufwändiger zu implementieren sein - vor allem für Entwickler, welche noch wenig / keine Erfahrung mit dem Stil besitzen
* Umfangreiche Codebase / Boilerplate-Code: +
Die Verwendung von Layer-Abstraktionen und vordefinierten Mappings zwischen den Layern kann zu Boilerplate-Code und - darausfolgend - einer umfangreicheren Codebase führen

|**Entscheidung**|A2) Hexagonal architecture (Ports & Adapters)
|**Begründung**|Die Verwendung einer hexagonalen Mikroarchitektur (Ports & Adapters) deckt die erhöhte Priorität betreffend Modifizierbarkeit / Erweiterbarkeit optimal ab. +
Die Businesslogik wird mit definierten Abstraktionen (Ports) sauber von allen externen Abhängigkeiten (Adapters) separiert, was zu einer losen Kopplung führt. Für die innere Struktur der Businesslogik setzen wir nicht explizit auf Clean / Onion Architecture, da dieser Ansatz für unser Domänenmodell zu komplex wäre und daher over-engineered wäre.
|**Follow-up Entscheidungen**|-
|===

==== Persistenz

[cols="2,6"]
|===
|**ID**|ADR-BAC-30
|**Anliegen (Concern)**|Werden mehrere (unterschiedliche) Datenbanken für PhysioConnect eingesetzt?
|**Kontext**
a|PhysioConnect persistiert unterschiedlichste Daten zur Laufzeit. Beispielsweise werden einerseits stetig aufgezeichnete Messdaten des Patienten abgelegt, andererseits aber auch allgemeine Therapiedaten. Im Rahmen dieser Entscheidung soll analysiert werden, ob die Verwendung mehrerer (unterschiedlicher) Datenbanken für die Persistierung der Daten eingesetzt werden sollen.
|**Alternativen**
a|
**A1) Alle Daten in derselben Datenbank**

__Vorteile:__

* Die Verwaltung der Daten ist einfacher, da alles an einem zentralen Ort abgelegt ist.
* Die Datenkonsistenz kann einfacher gewährleistet werden.
** Ein eventuell benötigtes Transaktionsmanagement kann out-of-the-box über mehrere Tabellen verwendet werden.
* Die Verwendung einer einzelnen Datenbank kann kostengünstiger sein als die Verwendung mehrerer Datenbanken, insbesondere wenn man einen Cloud-basierten Datenbankdienst nutzt, welcher nach Verbrauch abrechnet.

__Nachteile:__

* Vor allem bei unterschiedlichen Speicherintervallen und verschiedenen, grossen Datenmengen kann die Datenbank sehr schnell an Komplexität gewinnen und an Performance verlieren. Beispielsweise könnten die Patienten-Messdaten im Sekundentakt eingehen und abgelegt werden, während die allgemeinen Therapiedaten vielleicht nur monatlich einmal aktualisiert werden.

**A2) Separate Datenbank für die Patienten-Messdaten**

__Vorteile:__

* Besser geeignet wenn Daten mit unterschiedlichen Speicher- und Verarbeitungsanforderungen abgelegt werden sollen. Bei Daten, welche unterschiedliche Speicher- oder Verarbeitungsfunktionen erfordern, kann es sinnvoll sein, diese in getrennten Datenbanken zu speichern. So können beispielsweise strukturierte Daten, auf die häufig zugegriffen wird, in einer relationalen Datenbank und grosse Mengen unstrukturierter Daten in einer NoSQL-Datenbank persistiert werden.
* Besser geeignet wenn Daten mit unterschiedlichen Sicherheitsanforderungen abgelegt werden sollen. Bei Daten, welche unterschiedliche Sicherheitsstufen erfordern, kann es sinnvoll sein, diese in getrennten Datenbanken zu speichern. So können beispielsweise sensible Patienten-Messdaten in einer separaten, eventuell verschlüsselten Datenbank persistiert werden, während Therapiedaten in einer "normalen" Datenbank abgelegt werden.
* Besser geeignet wenn man grosse Datenmengen verzeichnet. Eine diesbezügliche Verteilung der Datenmengen auf mehrere Datenbanken kann die Leistung und Skalierbarkeit des Gesamtsystems verbessern.
* Besser geeignet wenn man mehrere Anwendungen unterstützen soll, welche jeweils auf unterschiedliche Teilmengen von Daten zugreifen müssen.

__Nachteile:__

* Die Verwendung mehrerer Datenbanken (vor allem auch wenn sie nicht demselben Modell entsprechen) kann die Gesamtkomplexität des Systems (Implementation, Betrieb, Wartung) generell stark erhöhen.

|**Entscheidung**|A2) Separate Datenbank für die Patienten-Messdaten
|**Begründung**|Wir erachten es als sinnvoll, die eingehenden Patienten-Messdaten in einer separaten Datenbank zu persistieren, da sie einerseits andere Sicherheitsanforderungen als die herkömmlichen Therapiedaten erfüllen müssen (Stichwort Datenschutz / Privacy) und andererseits viel frequentierter abgelegt werden, was zu einer beachtlich grösseren Datenmenge führen wird.
|**Follow-up Entscheidungen**
a|
* **ADR-BAC-31** +
Welche Datenbankmodelle werden für PhysioConnect eingesetzt?

|===

[cols="2,6"]
|===
|**ID**|ADR-BAC-31
|**Anliegen (Concern)**|Welche Datenbankmodelle werden für PhysioConnect eingesetzt?
|**Kontext**
a|PhysioConnect persistiert unterschiedlichste Daten zur Laufzeit. Beispielsweise werden einerseits stetig aufgezeichnete Messdaten des Patienten abgelegt, andererseits aber auch allgemeine Therapiedaten. Im Rahmen dieser Entscheidung soll analysiert werden, welche Datenbankmodelle für die unterschiedlichen Datenarten und Anwendungsfälle von PhysioConnect passend sein könnten.
|**Alternativen**
a|
**A1) Relationale Datenbank**

__Verwendungszwecke:__

* Verwaltung von strukturierten Daten, welche einem vordefinierten, statischen Schema folgen
* Eignet sich für Anwendungen, welche ein hohes Mass an Datenintegrität erfordern, wie beispielsweise Finanz- oder Gesundheitssysteme 
* Durchführung komplexer Datenabfragen
* Definition von Datenbeschränkungen, um die Genauigkeit und Konsistenz der Daten zu gewährleisten

__Vorteile:__

* Strukturierte Daten: +
Relationale Datenbanken sind darauf ausgelegt, strukturierte Daten zu speichern, was die Suche und den Abruf bestimmter Daten mit SQL-Abfragen erleichtert.
* Datenintegrität: +
Relationale Datenbanken erzwingen Datenintegritätsbeschränkungen, was bedeutet, dass die Daten konsistent und genau gespeichert werden.
* Skalierbarkeit: +
Relationale Datenbanken sind in der Lage, grosse Datenmengen zu verarbeiten, und können bei wachsendem Umfang der Datenbank einfach skaliert werden.
* Sicherheit: +
Relationale Datenbanken bieten Sicherheitsfunktionen wie Benutzerauthentifizierung, Datenverschlüsselung und Zugriffskontrolle.

__Nachteile:__

* Komplexität: +
Relationale Datenbanken können aufwändig in der Einrichtung und Wartung sein, insbesondere bei grossen und komplexen Systemen.
* Performance: +
Relationale Datenbanken können bei der Verarbeitung grosser Datenmengen oder einer hohen Anzahl gleichzeitiger Benutzer Performanceprobleme aufweisen.
* Flexibilität: +
Relationale Datenbanken sind nicht so flexibel wie einige NoSQL-Datenbanken, was die Speicherung komplexer oder unstrukturierter Daten erschweren kann.
* Kosten: +
Relationale Datenbanken können im Vergleich zu einigen NoSQL-Datenbanken teurer in der Einrichtung und Wartung sein.

**A2) Objektorientierte Datenbank**

__Verwendungszwecke:__

* Verwaltung von komplexen Datenstrukturen, welche nicht in ein herkömmliches relationales Schema passen
* Integration in Anwendungen, welche objektorientierte Programmiersprachen wie Java und C++ verwenden
* Verwaltung grosser Datenmengen
* Eignet sich für Anwendungen, welche ein hohes Mass an Flexibilität und Anpassungsfähigkeit erfordern, wie beispielsweise Datenanalyse- oder maschinelle Lernsysteme

__Vorteile:__

* Datenmodellierung: +
Objektorientierte Datenbanken ermöglichen eine natürlichere und intuitivere Datenmodellierung mittels Verwendung von Objekten und Klassen.
* Datenintegrität: +
Objektorientierte Datenbanken erzwingen Datenintegritätsbeschränkungen und stellen so sicher, dass die Daten konsistent und korrekt gespeichert werden.
* Skalierbarkeit: +
Objektorientierte Datenbanken sind in der Lage, grosse Datenmengen zu verarbeiten und lassen sich leicht skalieren, wenn der Umfang der Datenbank wächst.
* Integration: +
Objektorientierte Datenbanken lassen sich leicht in objektorientierte Programmiersprachen wie Java oder C++ integrieren.

__Nachteile:__

* Komplexität: +
Objektorientierte Datenbanken können sehr komplex in der Einrichtung und Wartung sein, insbesondere bei grossen und komplexen Systemen.
* Performance: +
Bei objektorientierten Datenbanken kann es zu Performanceproblemen kommen, wenn grosse Datenmengen oder eine hohe Anzahl gleichzeitiger Benutzer verarbeitet werden.
* Kompatibilität: +
Objektorientierte Datenbanken sind möglicherweise nicht mit allen Anwendungen und Programmiersprachen kompatibel.
* Kosten: +
Die Einrichtung und Wartung objektorientierter Datenbanken kann im Vergleich zu einigen anderen Datenbankarten teurer sein.

**A3) Dokumentdatenbank**

__Verwendungszwecke:__

* Verwaltung unstrukturierter oder halbstrukturierter Daten, welche nicht gut in ein traditionelles relationales Schema passen
* Verwaltung grosser Datenmengen
* Eignet sich für Anwendungen, welche ein hohes Mass an Flexibilität und die Fähigkeit erfordern, Daten schnell und effizient zu speichern und abzurufen
* Eignet sich für Anwendungen, welche ein hohes Mass an Skalierbarkeit und die Fähigkeit erfordern, eine grosse Anzahl gleichzeitiger Benutzer zu verarbeiten

__Vorteile:__

* Flexibilität: +
Dokumentdatenbanken sind für die Speicherung unstrukturierter Daten konzipiert, was sie flexibler macht als relationale Datenbanken.
* Skalierbarkeit: +
Dokumentdatenbanken sind in der Lage, grosse Datenmengen zu verarbeiten und lassen sich leicht skalieren, wenn der Umfang der Datenbank wächst.
* Performance: +
Dokumentdatenbanken sind im Allgemeinen performanter und effizienter als relationale Datenbanken, wenn es um das Lesen und Schreiben von Daten geht.
* Benutzerfreundlichkeit: +
Dokumentdatenbanken sind im Vergleich zu relationalen Datenbanken oft einfacher einzurichten und zu pflegen - insbesondere für Entwickler, die mit dem JSON-Datenformat vertraut sind.

__Nachteile:__

* Datenmodellierung: +
Es kann schwieriger sein, Daten in einer Dokumentdatenbank zu modellieren als in einer relationalen Datenbank, insbesondere bei komplexen Datenstrukturen.
* Datenintegrität: +
In Dokumentdatenbanken werden Einschränkungen der Datenintegrität möglicherweise nicht so streng durchgesetzt wie in relationalen Datenbanken, was zu Dateninkonsistenzen führen kann.
* Kompatibilität: +
Dokumentdatenbanken sind möglicherweise nicht mit allen Anwendungen und Programmiersprachen kompatibel.
* Kosten: +
Die Einrichtung und Wartung von Dokumentdatenbanken kann im Vergleich zu anderen Datenbankmodellen teurer sein.

**A4) Graphdatenbank**

__Verwendungszwecke:__

* Verwaltung komplexer, miteinander verknüpfter Daten und deren Beziehungen untereinander
* Verwaltung grosser Mengen von Echtzeitdaten
* Eignet sich für Anwendungen, welche ein hohes Mass an Flexibilität und die Fähigkeit erfordern, Datenbeziehungen schnell und effizient abzufragen und zu analysieren
* Eignet sich für Anwendungen, welche ein hohes Mass an Skalierbarkeit und die Fähigkeit erfordern, eine grosse Anzahl gleichzeitiger Benutzer zu verarbeiten

__Vorteile:__

* Datenmodellierung: +
Graphdatenbanken eignen sich gut für die Speicherung komplexer, miteinander verbundener Daten und können Beziehungen zwischen Daten auf eine natürlichere und intuitivere Weise modellieren.
* Performance: +
Graphdatenbanken sind im Allgemeinen performanter als relationale Datenbanken, wenn es darum geht, Daten abzufragen und Muster in grossen, komplexen Datensätzen zu finden.
* Skalierbarkeit: +
Graphdatenbanken können grosse Datenmengen verarbeiten und lassen sich bei wachsendem Umfang der Datenbank einfach skalieren.
* Verarbeitung von Echtzeitdaten: +
Graphdatenbanken eignen sich gut für die Verarbeitung von Echtzeitdaten und können Daten schnell aktualisieren und abfragen, wenn sie sich ändern.

__Nachteile:__

* Komplexität: +
Die Einrichtung und Pflege von Graphdatenbanken kann komplex sein, insbesondere bei grossen und komplexen Systemen.
* Datenintegrität: +
Graphdatenbanken setzen Datenintegritätsbeschränkungen möglicherweise nicht so streng durch wie relationale Datenbanken, was zu Dateninkonsistenzen führen kann.
* Kompatibilität: +
Graphdatenbanken sind möglicherweise nicht mit allen Anwendungen und Programmiersprachen kompatibel.
* Kosten: +
Die Einrichtung und Wartung von Graphdatenbanken kann im Vergleich zu anderen Datenbankmodellen teurer sein.

**A5) Zeitreihendatenbank**

__Verwendungszwecke:__

* Verwaltung von Daten mit Zeitstempel wie z.B. Sensor-, Finanz- oder Protokolldaten
* Verwaltung grosser Datenmengen
* Eignet sich für Anwendungen, welche ein hohes Mass an Performance und die Fähigkeit zur schnellen und effizienten Abfrage und Analyse von zeitbasierten Daten erfordern
* Eignet sich für Anwendungen, welche ein hohes Mass an Skalierbarkeit und die Fähigkeit erfordern, eine grosse Anzahl gleichzeitiger Benutzer zu verarbeiten

__Vorteile:__

* Datenmodellierung: +
Zeitreihendatenbanken sind speziell für die Speicherung und Abfrage von Zeitstempeldaten konzipiert, was die Modellierung und Analyse von zeitbasierten Daten erleichtert.
* Performance: +
Zeitreihendatenbanken sind für schnelle Schreibvorgänge und effiziente Abfragen von Zeitstempeldaten optimiert.
* Skalierbarkeit: +
Zeitreihendatenbanken können grosse Datenmengen verarbeiten und lassen sich leicht skalieren, wenn die Grösse der Datenbank zunimmt.
* Datenkompression: +
Zeitreihendatenbanken können Datenkomprimierungstechniken verwenden, um die Grösse der Datenbank zu verringern und die Performance zu verbessern.

__Nachteile:__

* Komplexität: +
Die Einrichtung und Pflege von Zeitreihendatenbanken kann komplex sein, insbesondere bei grossen und komplexen Systemen.
* Kompatibilität: +
Zeitreihendatenbanken sind möglicherweise nicht mit allen Anwendungen und Programmiersprachen kompatibel.
* Kosten: +
Die Einrichtung und Pflege von Zeitreihendatenbanken kann im Vergleich zu anderen Datenbanktypen teurer sein.
* Begrenzte Datentypen: +
Zeitreihendatenbanken sind für die Speicherung und Abfrage von Zeitstempeldaten optimiert und unterstützen andere Datentypen möglicherweise nicht so effizient.

|**Entscheidung**
a|
Kombination aus

* A1) Relationale Datenbank oder A3) Dokumentdatenbank +
Für alle Daten ausser die Patienten-Messdaten
* A3) Dokumentdatenbank +
Für die Patienten-Messdaten

|**Begründung**|Für die Ablage aller Daten, welche nicht zu den Patienten-Messdaten gehören, sollte eine herkömmliche relationale Datenbank allen Anforderungen gerecht werden. Alternativ könnte eine Dokumentdatenbank ebenfalls passend eingesetzt werden. +
Für die Persistierung der Patienten-Messdaten sollte hingegen primär auf eine Dokumentdatenbank zurückgegriffen werden, da sie auf die Ablage halb- oder unstrukturierter Daten spezialisiert sind und eine hohe Performance bezüglich Schreib- und Lesevorgängen vorweisen können.
|**Follow-up Entscheidungen**|-
|===

==== Messaging

[cols="2,6"]
|===
|**ID**|ADR-MES-10
|**Anliegen (Concern)**|Wie wird das Backend-Messaging innerhalb von Physio Connect umgesetzt?
|**Kontext**
|Sowohl Requests von Physiotherapeuten als auch von Patienten werden vom PhysioConnect-Backend gehandhabt. Zu Peak-Zeiten kann es sich dabei um eine hohe Anzahl von Requests bzw. eine hohe eingehende Datenmenge handeln. Da das PhysioConnect-Backend gemäss Architekturentscheid __ADR-BAC-10__ aus mehreren Microservices bestehen wird, soll überprüft werden, ob eine Messaging-Komponente eingesetzt werden soll und falls ja, welche.
|**Alternativen**
a|

**A1) HTTP(S)**

__Vorteile:__

* Einfache Implementierung
* Know-How weit verbreitet
* Von vielen verschiedenen Libraries unterstützt

__Nachteile:__

* Weniger effizient als einige Alternativen

**A2) Message Queues**

(RabbitMQ, Kafka)

__Vorteile:__

* Kann je nach Implementierungsart Requests effizient abarbeiten (Trade-off mit Traceablility)
* Gruppierung zusammenhängender Messages nach Themen (Topics)
* Skalierbare Messaging-Komponente
* Sender muss nicht darauf warten, bis die Message verarbeitet wurde
* Bei Ausfall der Datenbank könnten die Daten kurzfristig in der Queue als Messages persistiert werden, bis die Datenbank wieder erreichbar ist

__Nachteile:__

* Benötigt Messaging Container
* Erhöht Komplexität der Lösung
* Know-How kann sehr punktuell sein

**A3) gRPC**

__Vorteile:__

* Sehr performant
* Ermöglicht bidirektionale Kommunikation

__Nachteile:__

* Mehraufwand für die Implementation
* Weniger breite Unterstützung als andere Ansätze
* Weniger Know-How vorhanden

|**Entscheidung**|A1) HTTP(S)
|**Begründung**
a|

* Kommunikation mit HTTP(S) hat die geringste Komplexität
* Time-to-Market ist in einem ersten Schritt wichtiger als die Performance
* Für eine geringe Anzahl Benutzer wird es einfach sein, eine gute Performance mittels Skalierung zu erreichen
* Es ist einfacher, Bottlenecks zu erkennen und zu optimieren, wenn das System bereits produktiv im Einsatz ist

Es soll jedoch bei Design und Implementation darauf geachtet werden, dass die Möglichkeit der zukünftig gezielten Verwendung von gRPC oder einer Message Queue erhalten bleibt.

|**Follow-up Entscheidungen**|-
|===

=== Hosting

[cols="2,6"]
|===
|**ID**|ADR-HST-10
|**Anliegen (Concern)**|Wie wird Physio Connect gehosted?
|**Kontext**|Physio Connect ist eine Unterstützungs- und Integrationssoftware und zielt nicht darauf ab, kundenseitig bereits eingesetzte Systeme und Prozesse abzulösen, sondern nimmt eine komplementäre Rolle ein. Deshalb stellt sich die Frage, welches Hosting-Modell den Kunden das ideale Verhältnis zwischen (Integrations- / Betriebs-)Aufwand, Komplexität, Effizienz und Kompatibilität zur Verfügung stellt.
|**Alternativen**
a|

**A1) Hosting bei etabliertem Cloud-Provider**

(Microsoft, Amazon, Google, IBM)

__Vorteile:__

* Keine Vorlaufkosten für die Infrastruktur: +
Der Aufwand und die Komplexität bezüglich Kauf, Einrichtung und Wartung physischer Server fallen weg. Dies kann besonders für kleine bis mittlere Unternehmen (KMU) oder Startups nützlich sein, die möglicherweise nicht über die Ressourcen und / oder das Know-How verfügen, um eine eigene Infrastruktur zu betreiben.
* "Pay as you go": +
Bei den aktuellen Cloud-Providern zahlt man nur für die Ressourcen, welche man auch effektiv nutzt. Dies kann kosteneffizienter sein als das Hosting on-premise, insbesondere wenn es zu variablen oder unvorhersehbaren Mustern im Netzwerkverkehr / -auslastung kommen kann.
* Skalierbarkeit: +
Bei den aktuellen Cloud-Providern kann die Leistung je nach Bedarf problemlos erhöht oder verringert werden. Bei einem plötzlichen Anstieg des Datenverkehrs können schnell weitere Ressourcen horizontal oder vertikal hinzugefügt werden, um die Last zu bewältigen.
* Hohe Verfügbarkeit: +
Cloud-Provider bieten häufig Hochverfügbarkeitsoptionen an, z.B. auch über mehrere Verfügbarkeitszonen oder Regionen, welche sicherstellen, dass die gehostete Anwendung optimal verfügbar ist.
* Infrastructure as Code: +
Alle aktuellen Cloud-Provider bieten die Möglichkeit, die benötigten Infrastrukturressourcen automatisiert via Quellcode zu erstellen, modifizieren und - falls nötig - wieder abzubauen. Die automatisierte Verwaltung der Infrastruktur lässt sich zudem nahtlos in eine CI/CD-Pipeline integrieren, was zu einem grundsätzlich agilen Software Development Lifecycle beiträgt. +
Bei einem on-premise Hosting ist die Möglichkeit von __Infrastructure as Code__ in den meisten Fällen nicht gegeben.

__Nachteile:__

* Potenzielle Sicherheitsbedenken: +
Auch wenn die aktuellen Cloud-Provider unterschiedliche Massnahmen zur Sicherung der eingesetzten Infrastruktur ergreifen, besteht immer noch das Risiko, dass die übermittelten, verarbeiteten und / oder abgelegten Daten gefährdet sein könnten. Dieses Risiko kann jedoch durch die Anwendung bewährter Sicherheitspraktiken und die Befolgung der Anweisungen des präferierten Cloud-Providers mitigiert werden. +
Ein ebenfalls zu berücksichtigender Aspekt ist Datenschutz / Privacy - beispielsweise herrschen an gewissen Server-Standorten unterschiedliche Verordnungen / Gesetze diesbezüglich.
* Begrenzte Kontrolle: +
Das Hosting der Anwendung bei einem Cloud-Provider bedeutet gleichzeitig auch, dass man von der Infrastruktur und den Serviceangeboten des Providers abhängig ist. Dies kann ein Trade-Off für den Komfort sein, keine eigenen Server(-Farmen) verwalten zu müssen.
* Interne Vorlagen: +
Einige Gesundheitsinstitute besitzen (nicht gesetzlichen) Vorlagen, dass Daten in der internen Infrastruktur abgelegt werden müssen. Im Falle einer solchen Vorlage ist das Hosting in der Cloud nicht möglich.

**A2) On-premise beim Kunden**

__Vorteile:__

* Vollständige Kontrolle: +
Bei einem on-premise Hosting besitzt man (bzw. in diesem Fall der Kunde) die vollständige Kontrolle über die Hardware, Software und Infrastruktur. Dies kann von Vorteil sein, wenn spezielle Sicherheits- oder Compliance-Anforderungen vorliegen, welche von einem Cloud-Provider nicht (oder nur eingeschränkt) erfüllt werden können.
* Vorhersehbare Kosten: +
Bei einem on-premise Hosting können die Kosten in der Regel genauer und verlässlicher prognostiziert werden, da sie nicht an die Nutzung ("Pay as you go") gebunden sind.
* (Potenziell) Bessere Performance: +
In einigen Fällen kann ein on-premise Hosting zu einer besseren Performance führen, da man nicht von einer konstanten Internetverbindung oder der Leistung eines Remote-Servers abhängig ist.

__Nachteile:__

* Höhere Vorabkosten: +
Ein on-premise Hosting erfordert grössere vorgängige Investitionen in Hardware, Software und Infrastruktur.
* Wartung und Support: +
Bei einem on-premise Hosting ist der Kunde selbst für die Wartung und Unterstützung der Infrastruktur verantwortlich. Dies kann ressourcenaufwändig sein und spezielles technisches Know-How erfordern.
* Eingeschränkte Skalierbarkeit: +
Es kann komplex und kostenaufwändig sein, eine on-premise gehostete Infrastruktur nach Bedarf horizontal oder vertikal zu skalieren.
* Kleinere, selbstgewartete IT Infrastrukturen besitzen häufiger Sicherheitslücken als die von grossen Cloud Anbietern.

|**Entscheidung**|A1) Hosting bei etabliertem Cloud-Provider

Die Möglichkeit, dass - je nach Kunde - die Alternative __A2) On-premise beim Kunden__ zum Einsatz kommen kann, wird nicht ausgeschlossen, sollte jedoch ein Ausnahmefall bleiben.
|**Begründung**
a|
Das definierte link:04_solution_strategy.adoc#section-solution-strategy[Architekturprinzip AP-6] gibt bereits die Richtlinie vor, im Rahmen von Physio Connect grundsätzlich das https://aws.amazon.com/what-is/cloud-native/[Cloud Native-Prinzip] zu befolgen. Auf diese Weise bleibt Physio Connect skalierbar, flexibel, resilient und kann effizient auf neue Kundenbedürfnisse angepasst werden.

Es soll jedoch bei Design und Implementation darauf geachtet werden, dass ein potenzielles on-premise Hosting aus technischer Sicht nicht verbaut wird.

|**Follow-up Entscheidungen**
a|
* **ADR-HST-11** +
Hosten wir eine einzige Physio Connect Instanz oder eine pro Kunde? 
|===


[cols="2,6"]
|===
|**ID**|ADR-HST-11
|**Anliegen (Concern)**|Hosten wir eine einzelne Physio Connect Instanz oder eine Instanz pro Kunde? 
|**Kontext**|Gemäss ADR-HST-10 hosten wir PhysioConnect auf einem etablierten Cloud Anbieter. 
|**Alternativen**
a|

**A1) Einzelne Instanz**

__Vorteile:__

* Einzelne Produktivversion im Einsatz
* Relative einfache Implementation für CI/CD
* Erhöhte User Experience durch einzelne URL für das Planungsmanager Interface
** Falls ein Patient das Physio Connect System zuerst in der Reha verwendet und anschliessend in einer privaten Praxis hätten diese unterschiedliche URLs
* Skalierbarkeit kann gemäss Gesetz der grossen Zahlen optimiert werden
* Einfachere Implementation für Fallback System
* Einfachere Implementation für Backups

__Nachteile:__

* Falls ein Upgrade eine Datenmigration benötigt, muss dies bei allen Kunden gleichzeitig gemacht werden
* Falls das System abstürzen sollte ist es für alle Kunden nicht verfügbar
* Keine direkte Abrechnung für Infrastruktur möglich

**A2) Eine Instanz pro Kunde**

__Vorteile:__

* Einfachere Individualisierbarkeit und Konfigurierbarkeit pro Kunde.
* Möglichkeit für hosting auf verschiedenen Cloud Anbietern.
* Infrastrukturkosten pro Kunde können genau Abgerechnet werden.
* Deploymentprozess wäre besser darauf ausgerichtet, Hosting beim Kunden zusätzlich zu unterstützen.
* Versionsupgrades können Phasenweise ausgerollt werden.

__Nachteile:__

* System muss für jeden Kunden neu Aufgesetzt werden.
* Pro eingesetzte Version müssen Patches geliefert werden können.
* Verschiedene Versionen des Physio Connect Systems müssen mit der Benutzerverwaltung und dem Übungskatalogs kompatibel sein.
* Automatisierte Tests müssen regelmässig auf allen Versionen ausgeführt werden.
* Hoher Supportaufwand für die Systeme.
* Von uns angebotene "Testphasen" müssten einzeln gehostet werden. Übergang von Testphase zum effektiven Einsatz ist mit Aufwand verbunden.
 
|**Entscheidung**| A1) Einzelne Instanz

Da die Möglichkeit __ADR-HST-10 A2) On-premise beim Kunden__ zum Einsatz kommen kann, wird es trotzdem möglich sein, einzelne Instanz für einen Kunden in der Cloud zu deployen
|**Begründung**
a|
Für den Verkauf unseres Produktes sind tiefe Einführungskosten essentiell. Zusätzlich können wir uns als Startup keinen Support für eine Vielzahl von Versionen leisten. Falls einzelne Instanzen für Kunden gepflegt werden müssen, sollen diese auf der gleichen Version wie unsere "Hauptinstanz" gehalten werden.

|**Follow-up Entscheidungen**|-
|===