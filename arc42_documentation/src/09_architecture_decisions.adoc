[[section-design-decisions]]
== Architekturentscheidungen

In diesem Kapitel werden alle relevanten Architekturentscheidungen in Form von __Architectural Decision Records (ADRs)__ gemäss https://www.iso.org/standard/50508.html[ISO 42010] definiert. +
Die Entscheidungen sind jeweils thematisch gruppiert, damit sie besser auffindbar sind.

Das Format der Entscheidungen basiert auf dem folgenden Template:

[cols="2,6"]
|===
|**ID**|ADR-[Kategorie]-[Nummer]
|**Anliegen (Concern)**|Anliegen, welches die Grundlage für die Entscheidung darstellt. Formuliert als Fragestellung.
|**Kontext**|Beschreibung der Ausgangslage, um die Relevanz des Anliegens hervorzuheben.
|**Alternativen**
a|
Auflistung der möglichen Alternativen, inkl. deren Vor- und Nachteile.

* [Option 1]
** Beschreibung
** Vorteile
** Nachteile
* [Option 2]
** ...
* [Option 3]
** ...

|**Entscheidung**|Resultat der Entscheidungsfindung bzw. welche der Alternativen eingesetzt wird.
|**Begründung**
a|

* Weshalb wurde Alternative x ausgewählt?
* Beschreibung der eventuellen Konsequenzen (positiv oder negativ), welche beim Einsatz der Alternative x speziell zu beachten sind

|**Follow-up Entscheidungen**|Auflistung der benötigten Entscheidungen, welche aus dieser Entscheidung resultieren und zusätzlich getroffen werden müssen.
|===

=== Security

[cols="2,6"]
|===
|**ID**|ADR-SEC-10
|**Anliegen (Concern)**|Wie wird ein Systemkonsument sicher authentifiziert?
|**Kontext**|Sowohl die bereitgestellte API als auch die Webapplikation (SPA, PWA) von PhysioConnect darf lediglich von Konsumenten (Benutzer oder Systeme) verwendet werden, welche in der Benutzerverwaltung als gültige Benutzer registriert sind. Bei jedem Kommunikationsvorgang muss daher sichergestellt werden, dass die Identität der konsumierenden Partei erfolgreich verifiziert werden konnte.
|**Alternativen**
a|
**Voraussetzungen**

__Allgemein__

Das System "Benutzerverwaltung" gibt bereits die folgenden Rahmenbedingungen vor:

* Als Identity Provider wird https://www.keycloak.org/[Keycloak] verwendet
* Keycloak unterstützt Multi-factor authentication
1. Passwort des Benutzers
2. One-time password via https://googleauthenticator.net/[Google Authenticator] oder https://freeotp.github.io/[FreeOTP]

Nachfolgend werden die kompatiblen Alternativen gelistet.

**A1) HTTP basic authentication** +
Authentifizierung mittels vordefiniertem Username und Passwort. Die Credentials werden mit Base64 transformiert und mit jedem Request als Teil des HTTP Headers mitgegeben. +

__Vorteile:__

* Einfache Implementation +
(Encoding von Username & Passwort mit Base64)
* Einfache Übertragung via HTTP Header
* Keine komplexen Handshake- / Callback-Login-Mechanismen notwendig

__Nachteile:__

* Sollte nicht ohne HTTPS / SSL / TLS verwendet werden
* Anfällig für Hijacking- und Man-in-the-middle-Attacken wenn unverschlüsselte Verbindung
* Grössere Angriffsfläche, da Username / Passwort mit jedem Request quasi als Klartext (Base64) mitgesendet werden
* Passwort wird eventuell im Browsercache abgelegt, was CSRF-Attacken begünstigt
* Im Falle eines erfolgreichen Angriffs sind die Benutzer-Credentials (Username & Passwort) in den Händen des Angreifers, was (je nach internen Rollen und Berechtigungen des betroffenen Benutzers) zu einer immensen Verletzlichkeit des Gesamtsystems führen kann

**A2) API Key** +
Authentifizierung mittels generiertem API Key. Letzterer wird mit jedem Request als Teil des HTTP Headers mitgegeben. +

__Vorteile:__

* Einfache Implementation
* Einfache Übertragung via HTTP Header
* Keine komplexen Handshake- / Callback-Login-Mechanismen notwendig
* Bequemer, da API Keys invalidieren und neu generieren kann, ohne das Passwort eines Benutzeraccounts zu ändern
* Im Falle einer Kompromittierung ist die Angriffsfläche auf die API beschränkt, nicht auf den gesamten Benutzeraccount
* Es können unterschiedliche Keys pro Benutzeraccount, Umgebung und Access Scope generiert werden (z.B. DEV / PROD Key mit Read / Write Access)

__Nachteile:__

* Sollte nicht ohne HTTPS / SSL / TLS verwendet werden
* Anfällig für Hijacking- und Man-in-the-middle-Attacken wenn unverschlüsselte Verbindung
* Grössere Angriffsfläche, da der API Key mit jedem Request als Klartext mitgesendet wird
* Im Falle eines erfolgreichen Angriffs ist die gesamte API kompromittiert

**A3) OAuth 2.0 mit OpenID Connect und Bearer Token (JWT)** +
Authentifizierung via https://oauth.net/2/[OAuth 2.0]-Flow mit https://openid.net/connect/[OpenID Connect]. OAuth 2.0 ist ein etabliertes Autorisierungsframework und bietet eine Spezifikation für die Implementation von Autorisierungsprotokollen und -flows. OpenID Connect basiert auf dem OAuth 2.0-Framework und ist ein Standard, welcher speziell auf die Benutzerauthentifikation ausgerichtet ist.

__Vorteile:__

* Etabliertes Framework - es gibt zahlreiche Online-Dokumentationen und Guides
* State-of-the-art bezüglich der Absicherung von APIs
* Ausgestellte Bearer Tokens (JWT) können seitens API einfach auf ihre Integrität und Gültigkeit validiert werden
* Tokens können auf feingranulare API Scopes ausgestellt werden, was die Angriffsfläche theoretisch reduziert
* Möglichkeit, zusätzliche Refresh Tokens zu verwenden, welche bei Ablauf eines Access Tokens automatisch einen neuen anfordern
* Unterstützt Single Sign-On (SSO)
* Ausgestellte Bearer Tokens (JWT) können Browser-seitig in einem Cookie abgelegt werden (bzw. Standardverhalten für manche Identity Provider), damit sie nicht alternativ im Local oder Session Storage gespeichert werden müssen
* Unterstützung verschiedener Client-Typen (z.B. Device, SPA / Public client)

__Nachteile:__

* Ist nicht immer ganz einfach zu implementieren
* Kann bei falscher Implementation und / oder Konfiguration zu https://www.rfc-editor.org/rfc/rfc6819#section-4[Sicherheitslücken] führen

**A4) SAML** +
Authentifizierung via https://auth0.com/blog/how-saml-authentication-works/[SAML]. Security Assertion Markup Language (SAML) ist - nebst OpenID Connect - ein weiterer Standard, welcher auf die Benutzerauthentifikation ausgerichtet ist.

__Vorteile:__

* Etablierter Standard
* Unterstützt Single Sign-On (SSO)

__Nachteile:__

* Alter Standard: Die neuste Version des Standards besteht bereits seit 2005
** nicht einfach, aktuelle Web- (SPA) und Mobileapplikationen mit SAML abzusichern
** OpenID Connect wurde unter anderem dafür entworfen, SAML abzulösen
* Verwendet XML anstelle von JSON Web Tokens (JWT) als Übertragungsformat
** erhöhter Ressourcenbedarf (Netzwerk & Memory) im Vergleich zu JWT
** bei der Implementation muss auf die bestehenden https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html[XML-Angriffsvektoren] Acht gegeben werden
* API Scopes werden nicht out-of-the-box unterstützt

|**Entscheidung**
a|
* A3) OAuth 2.0 mit OpenID Connect und Bearer Token (JWT)
* Multi-factor authentication (MFA)

|**Begründung**|Die Authentifizierung mit OAuth 2.0 und OpenID Connect ist eine etablierte und (zurzeit) sichere Methode zur Verifikation der Identität eines Systemkonsumenten. In der direkten Gegenüberstellung mit den restlichen Alternativen ist OAuth & OpenID Connect spezifisch darauf ausgelegt, den Authentifizierungsworkflow zwischen Frontend (SPA, PWA) und Backend (API) so sicher wie möglich zu gestalten. +
Vorsicht ist jedoch bei der Implementation und Konfiguration geboten - wie bereits als Nachteil dieser Variante erfasst, kann eine falsche Implementation und / oder Konfiguration zu Sicherheitslücken führen. Dies kann jedoch theoretisch bei jeder Alternative der Fall sein. +
OAuth 2.0 & OpenID Connect wird zudem von allen gängigen (Social) Identity Providern einwandfrei unterstützt.

Des Weiteren ist der supplementäre Einsatz von Multi-factor authentication (MFA) ein relevanter Bestandteil aktueller Authentifizierungsmechanismen und wird daher als notwendig angesehen. Hierbei wird auf die unterstützten MFA-Faktoren von Keycloak sowie den angebotenen Social Identity Providern (ADR-SEC-11) zurückgegriffen.
|**Follow-up Entscheidungen**
a|
* **ADR-SEC-11** +
Mit welchen Social Identity Providern kann sich ein Systembenutzer authentifizieren?

|===

[cols="2,6"]
|===
|**ID**|ADR-SEC-11
|**Anliegen (Concern)**|Mit welchen Social Identity Providern kann sich ein Systembenutzer authentifizieren?
|**Kontext**
a|Social Identity Providers wie Google, Microsoft oder Apple ermöglichen die Authentifizierung eines Benutzers über bereits existierende (Social Media) Accounts. Auf diese Weise werden Benutzerinformationen und Credentials (Username & Passwort) lediglich an einem zentralen Ort (nämlich beim betroffenen Social Identity Provider) verwaltet und nicht bei PhysioConnect redundant gehalten. +
Zudem ist der Login-Prozess über Social Identity Providers meist intuitiver, da die Benutzer meist denselben Account mit verschiedenen Services verknüpfen (z.B. Google-Account) und sich daher überall mit denselben Credentials und über dieselbe Login-Maske und Multi-factor authentication (MFA) authentifizieren können.
|**Alternativen**
a|
**Voraussetzungen**

__Allgemein__

Das System "Benutzerverwaltung" gibt bereits die folgenden Rahmenbedingungen vor:

* Als Identity Provider wird https://www.keycloak.org/[Keycloak] verwendet
* Keycloak unterstützt __identity provider federation__, sprich die Delegation der Authentifizierung zu verknüpften, externen (Social) Identity Providern. Voraussetzung für die Anbindung ist die Kompatibilität zu OAuth 2.0 & OpenID Connect.

__ADR-SEC-10__

* OAuth 2.0 & OpenID Connect wird unterstützt
* Multi-factor authentication (MFA) wird unterstützt

Nachfolgend werden die kompatiblen Alternativen gelistet.

**A1) Kein Social Identity Provider** +
PhysioConnect bietet keine Authentifizierung via Social Identity Provider an.

__Vorteile:__

* Kein Zusatzaufwand seitens PhysioConnect-Identity Provider (ADR-SEC-11) für die Einbindung externer Identity Providers
* Vollständige Kontrolle über alle Benutzeraccounts, da alle Informationen innerhalb des Systemkontexts abgelegt sind
* Keine zusätzlichen Datenschutz- / Privacy Concerns, da die Benutzerdaten nicht ausserhalb des Systemkontexts verwendet werden können
* Bei der Verwendung von Social Identity Providers wird das potenzielle Schadensausmass im Falle eines Account-Hijackings vergrössert. Beispielsweise kann sich ein Angreifer bei der Übernahme eines Google Accounts auf allen Webseiten anmelden, welche sich mittels Verwendung des Google Accounts authentifizieren 

__Nachteile:__

* Redundante Datenhaltung, da ein Grossteil der Benutzer bereits einen Account bei einem (oder mehreren) Social Identity Providers besitzt
* Eigene Login-Maske und Multi-factor authentication (MFA)-Prozess für alle Benutzer
* Benutzer müssen sich mit dedizierten Credentials (Username & Passwort) anmelden

**A2) Google** +
Authentifizierung über Google.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Google-Ökosystem befinden oder mehrheitlich Google-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller Android User inkludiert.

__Nachteile:__ +
-

**A3) Microsoft** +
Authentifizierung über Microsoft.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Microsoft-Ökosystem befinden oder mehrheitlich Microsoft-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller Windows User inkludiert.

__Nachteile:__ +
-

**A4) Apple** +
Authentifizierung über Apple.

__Vorteile:__

* Einbezug von Benutzern, welche sich ausschliesslich im Apple-Ökosystem befinden oder mehrheitlich Apple-Produkte und -Services verwenden. +
Beispielsweise ist hierbei der Grossteil aller iOS & macOS User inkludiert.

__Nachteile:__ +
-

|**Entscheidung**
a|
Verwendung von

* A1) Google
* A2) Microsoft
* A3) Apple

Die Möglichkeit der Authentifizierung über die obigen Social Identity Provider soll in erster Linie den Patienten (= externen Benutzeraccounts) zur Verfügung stehen. Die Benutzeraccounts von Physiotherapeuten, Vorgesetzten und weiteren kundenseitig internen Benutzern werden im Rahmen des Systems "Benutzerverwaltung" mit der bestehenden Identity & Access Management-Lösung des Kunden (z.B. Active Directory) synchronisiert. +
Eine Ausnahme bilden Kunden, welche ihre internen Benutzer bereits via Microsoft Accounts (z.B. via Office 365) authentifizieren.
|**Begründung**|Die Verwendung von Social Identity Providers bietet eine hohe Flexibilität bei relativ geringem Integrationsaufwand. Mit der Kombination aus Google, Microsoft und Apple sollte das Angebot an Social Identity Providern eine klare Mehrheit der zukünftigen Benutzer abdecken. +
Zudem kann auf diese Weise eine redundante Datenhaltung von Benutzeraccounts verhindert werden, da ein Grossteil der zukünftigen Benutzer bereits einen Account bei einem (oder mehreren) Social Identity Providers besitzt.

**Hinweis:** +
Diese Entscheidung führt zu entsprechenden Änderungen in PhysioConnect (Webapplikation, API) sowie dem System "Benutzerverwaltung" (Konfiguration der Social Identity Providers in Keycloak).
|**Follow-up Entscheidungen**|-
|===

=== Frontend Architektur

==== Plattformen

[cols="2,6"]
|===
|**ID**|ADR-FRO-10
|**Anliegen (Concern)**|Welche Plattformen sollen unterstützt werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden dieses Frontend hauptsächlich für die Planung und Auswertung von Therapien.

|**Alternativen**
a|

**Browser (exklusive Mobile-Browser)**

__Vorteile:__

* Applikation kann von einer sehr hohen Anzahl Geräten verwendet werden
* Eine Implementation deckt die Anwendung für verschiedene Betriebssysteme ab

__Nachteile:__

* Erhöhter Implementationsaufwand und Testaufwand durch Unterstützung verschiedener Browser

**Mobile-Browser**

__Vorteile:__

* Es wird keine Workstation benötigt, um die Applikation zu verwenden
* Relativ Zusatzaufwand falls Browser Applikation bereits entwickelt wird (gleiche Codebase)

__Nachteile:__

* Alle UI Elemente müssen so Umgesetzt werden, dass sie auf einem kleinen Screen funktionieren
* Erhöhter Testaufwand
* Mehr und schwerer zu Reproduzierende Fehler durch zusätzliche / veraltete Betriebssysteme und mobilen Browser

**Android App**

__Vorteile (im Vergleich zu nur Mobile Browser):__

* Erhöhte Benutzerfreundlichkeit für Android Anwender durch
** App auf dem Homescreen
** Bessere Unterstützung von gerätespezifischen Funktionalitäten wie Kamera

__Nachteile:__

* Es muss eine Implementationsart verwendet werden, mit welcher eine App aus der gleichen Codebase wie die Web Applikation generiert werden kann.

**iOS App**

__Vorteile:__

* Erhöhte Benutzerfreundlichkeit für iOS Anwender durch
** App auf dem Homescreen
** Bessere Unterstützung von gerätespezifischen Funktionalitäten wie Kamera

__Nachteile:__

* Es muss eine Implementationsart verwendet werden, mit welcher eine App aus der gleichen Codebase wie die Web Applikation generiert werden kann.

**Desktop Applikation**

__Vorteile:__

* Bessere Performance als Web Applications
* Bietet Offline Funktionalitäten an

__Nachteile:__

* Systemabhängig

|**Entscheidung**
|Muss: Browser & Mobile Browser. 

Kann: Android App & iOS App

|**Begründung**
a|
Da wir keinen Einfluss auf das System unserer Kunden haben schliesst dies eine Desktop Applikation aus. Web Applikationen genügen ausserdem für die für unser System benötigte Performance.

Da Physiotherapeuten oft nicht im Büro sind und trotzdem Zugriff auf die Therapiedaten haben müssen, müssen mobile Browser unterstützt werden.

Es wurden bereits Funktionalitäten gewünscht wie Fotografieren und Videoaufnahmen für Übungsbeschreibungen. Dies hätte eine höhere Usability in Apps als im Browser. Da der Implementationsaufwand minimal gehalten werden sollte und nur eine Codebase verwendet werden muss, wird dieser Entscheid bei der Analyse der zu verwendenden Technologien getroffen.

|**Follow-up Entscheidungen**|
ADR-FRO-11
|===

==== Frontend Architekturstil

[cols="2,6"]
|===
|**ID**|ADR-FRO-11
|**Anliegen (Concern)**|Welcher Architekturstiel soll für das PhysioConnect Frontend verwendet werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden dieses Frontend hauptsächlich für die Planung und Auswertung von Therapien. Mobile Browser müssen unterstützt werden.

|**Alternativen**
a|

**Single Page Application**

__Vorteile:__

* Hohe Responsiveness, da alles zum Start geladen wird
* Server muss nicht bei jedem Klick des Users requests entgegennehmen
* Rechenleistung der Clients kann verwendet werden

__Nachteile:__

* Häufige Reloads können zu einer hohen Datenlast führen
* Schlechte Suchmaschinenoptimierung
* Ausführung von Funktionalitäten direkt im Browser des Clients kann zu Sicherheitslücken führen

**Server Side Rendering**

__Vorteile:__

* Suchmaschinenoptimierung möglich
* Sichere Ausführung von Funktionen auf dem Server

__Nachteile:__

* Relativ tiefe Responsiveness
* Alle rechenleistungen müssen von uns zur Verfügung gestellt werden

**Static Side Generation**

__Vorteile:__

* Sehr schnell

__Nachteile:__

* Inhalt wird vorgeneriert und kann dementsprechend nicht  zu Echtzeit angepasst werden

|**Entscheidung**
|Single Page Application

|**Begründung**
a|
Wir haben uns für SPAs entschieden, da mit einer SPA sowohl unsere funktionalen Anforderungen als auch die Qualitätsattribute umgesetzt werden können. Die für SPAs typische Nachteile wie schlechte Suchmaschinenoptimierung sind für uns nur begrenzt relevant.

Mit Static Side Generation können nicht alle benötigten Funktionalitäten für Physio Connect umgesetzt werden.

Mit Server Side Rendering wäre es sehr Aufwendig, die Gewünschten Usability umzusetzen.


|**Follow-up Entscheidungen**|
ADR-FRO-12
|===

==== Frontend Technologie

[cols="2,6"]
|===
|**ID**|ADR-FRO-12
|**Anliegen (Concern)**|Mit welcher Technologie soll die Single Page Application Umgesetzt werden?

|**Kontext**
|Physiotherapeuten und Patienten verwenden dieses Frontend hauptsächlich für die Planung und Auswertung von Therapien. Mobile Browser müssen unterstützt werden. Es wurde bestimmt, dass eine SPA verwendet wird.

|**Alternativen**
a|

*Flutter*

__Vorteile:__

* Cross Plattform Applikation von einer Codebase

__Nachteile:__

* Kaum Know-How zu Dart Programming Language vorhanden
* Support für Web Applikationen schlechter verglichen mit den anderen Alternativen

*React*

__Vorteile:__

* Viel Know-How in der Community vorhanden
* Kompatibel mit vielen Libraries
* Sehr hohe Zufriedenheit in der State of JS Umfrage https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/

__Nachteile:__

* Relativ komplex zum erlernen

*Angular*

__Vorteile:__

* Viel Know-How in der Community vorhanden
* Hohe Unterstützung für Typescript

__Nachteile:__

* Komplex zum erlernen
* Tiefe Zufriedenheit in State of JS https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/

*Vue*

__Vorteile:__

* Einfacher zu erlernen als die Alternativen
* Relativ hohe Zufriedenheit in der State of JS Umfrage https://2021.stateofjs.com/en-US/libraries/front-end-frameworks/

__Nachteile:__

* Relativ kleine Community
* Verglichen wenig angebotene Features

|**Entscheidung**|React
|**Begründung**
a|
Der Hauptvorteil von Flutter, nämlich die Unterstützung von Geräten ausserhalb von Desktops und Apps, hat bei uns keine Priorität.

Für Angular gab es in den letzten Jahren viele schlechte Rückmeldungen.

VueJS und React sind beide für unser Projekt geeignet, React scheint jedoch eine aktivere Community zu besitzen und hat einen höhere Anzahl an direkt unterstützten Features, was den Implementationsaufwand senken sollte. Aus diesem Grund haben wir uns für React entschieden.

|**Follow-up Entscheidungen**|
ADR-FRO-13: 
Da das Framework nun bekannt ist kann entschieden werden, ob eine App unterstützt werden soll oder nicht.

ADR-FRO-14: 
Sollen Micro Frontends verwendet werden, um die SPA umzusetzen?

|===

==== Mobile Unterstützung

[cols="2,6"]
|===
|**ID**|ADR-FRO-13
|**Anliegen (Concern)**|Soll eine iOS und Android App aus der React App generiert werden? Falls ja, mit welcher Technologie?

|**Kontext**
|Es wurde entschieden, dass bei geringem Umsetzungsaufwand eine App für iOS und Android gemacht werden sollte. Zusätzlich wurde bestimmt, dass React zum Umsetzen der Web Applikation verwendet wird und dass nur eine Codebase existieren darf.

|**Alternativen**
a|

*Keine App*

__Vorteile:__

* Kein Entwicklungsaufwand

__Nachteile:__

* Keine App auf dem Homescreen
* Gerätespezifische Funktionen werden schlechter unterstützt
* Seite normalerweise nicht im Fullscreen

*Progressive Web App (PWA)*

__Vorteile:__

* Apps müssen nicht über einen Store veröffentlicht werden
* Apps besitzen immer die gleiche Version wie der Server. Falls mehrere Systeme im Einsatz sind (self Hosted vom Kunden), passt das App automatisch mit der Kundenversion überein

* Relativ geringer Umsetzungsaufwand
* Bietet eingeschränkte Offline Funktionalitäten an
* Da es sich weiterhin um ein Browserapp handelt und nicht auf die native Funktionalitäten zugreift muss nicht mit einer vielzahl von Devices getestet werden

__Nachteile:__

* Features nicht so ausgereift wie bei Native Apps
* iOS Safari bietet weniger Funktionalitäten an als Android

*React Native*

__Vorteile:__

* Bietet Offline Funktionalitäten an
* Verwendet Device native Funktionalitäten
* Relativ geringer Supportaufwand da Reactspezifische Lösung

__Nachteile:__

* Unterstützung von Native Funktionalitäten führt zu erhöhtem Testaufwand
* Es muss bestimmt werden, welche OS unterstützt werden. Diese sollten auch aktiv getestet werden.

*Cordova*

__Vorteile:__

* Bietet Offline Funktionalitäten an
* Verwendet Device native Funktionalitäten


__Nachteile:__

* Relativ hoher Supportaufwand da Cordova nicht nur für React entwickelt wird
* Unterstützung von Native Funktionalitäten führt zu erhöhtem Testaufwand
* Es muss bestimmt werden, welche OS unterstützt werden. Diese sollten auch aktiv getestet werden.


|**Entscheidung**|PWA
|**Begründung**
a|Es wurde PWA gewählt, da dies einen relativ geringen Umsetzungsaufwand benötigt und gleichzeitig alle Usabilty Requirements erfüllt. Der Vorteil von Native apps kann mit dem Physio Connect Vorteil kaum ausgenutzt werden, da hauptsächlich die Kamera verwendet wird und ansonsten nur Begrenzt Offline Content benötigt wird. Der Usability Vorteil, eine PWA umzusetzen, übertrifft den geringeren Implementationsaufwand für die Alternative "keine App".

|**Follow-up Entscheidungen**|
|===

==== Micro Frontends

[cols="2,6"]
|===
|**ID**|ADR-FRO-14
|**Anliegen (Concern)**|Sollen Micro Frontends eingesetzt werden?

|**Kontext**
|Es wurde entschieden, das Frontend mit SPA umzusetzen. Nun soll entschieden werden, ob für die Umsetzung zusätzlich Micro Frontends verwendet werden sollen.

|**Alternativen**
a|

**Micro Frontends**

__Vorteile:__

* Frontends können einzeln deployed werden
* Frontends können separat entwickelt werden
* Zur Umsetzung der Frontends können verschiedene Sprachen verwendet werden
* Frontends sind einzeln skalierbar

__Nachteile:__

* Erhöhte Komplexität für die Umsetzung
* Frontends müssen miteinander Kompatibel gehalten werden

**Keine Micro Frontends**
Umkehrung von der Alternative "Micro Frontends"

|**Entscheidung**|Keine Micro Frontends
|**Begründung**
a|

Die Vorteile von Micro Frontends können in Physio Connect kaum verwendet werden. Um die Komplexität gering zu halten wurde gegen Micro Frontends entschieden.

|**Follow-up Entscheidungen**|
|===

=== Backend Architektur

==== Architekturstil

[cols="2,6"]
|===
|**ID**|ADR-BAC-10
|**Anliegen (Concern)**|Welche Architekturstile sollen aus Sicht einer deploybaren Einheit eingesetzt werden?
|**Kontext**
a|
Das Backend von PhysioConnect besteht grundsätzlich aus den folgenden High Level-Komponenten:

* API Controllers / Request Handlers für die Entgegennahme und formale Kontrolle der eingehenden Requests
** Kommunikation mit Patienten-App +
(z.B. Übertragung der Messdaten, Start einer Therapie-Session)
** Kommunikation mit PhysioConnect-Webapplikation / -Frontend +
(z.B. Erstellung einer Therapie)
* Businesslogik für die fachliche Verarbeitung der Requests
* https://learn.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer[Anti-corruption layers] für die Kommunikation mit den Systemen "Übungskatalog" und "Benutzerverwaltung"

Diese Entscheidung befasst sich damit, welche Architekturstile für die obigen Komponenten hinsichtlich deren optimalen Kommunikation, Skalier- und Deploybarkeit eingesetzt werden können.
|**Alternativen**
a|
**A1) Monolith**

__Vorteile:__

* Einfachheit: +
Ein Monolith besteht aus einer einzigen, in sich geschlossenen Einheit, welche - verglichen mit verteilten Systemen - leicht zu verstehen ist
* Einfaches Deployment: +
Da es sich bei einem Monolith um eine einzige Einheit handelt, lässt sie sich einfach und atomar deployen

__Nachteile:__

* Eingeschränkte Skalierbarkeit: +
Es kann schwierig sein, einen Monolithen horizontal zu skalieren, da die gesamte Anwendung als eine einzige Einheit deployed werden muss
* Hohe Kopplung: +
Die internen Komponenten eines Monolithen sind meist eng miteinander gekoppelt, was die Änderung, Erweiterung und / oder Wiederverwendung einzelner Komponenten erschwert

**A2) Microservices**

__Vorteile:__

* Skalierbarkeit: +
Microservices können unabhängig voneinander skaliert werden, was wiederum die Skalierbarkeit des Gesamtsystems erhöht
* Wiederverwendbarkeit: +
Microservices sind kleine, unabhängige Funktionseinheiten und können daher in verschiedenen Kontexten wiederverwendet werden
* Erweiterbarkeit: +
Etwaige Modifikationen oder Erweiterungen eines Microservices sind mit geringer Komplexität realisierbar, da sich die darin befindlichen Funktionalitäten nur in dem jeweils betroffenen Microservice befinden und nicht über mehrere Services aufgetrennt sind
* Einfaches Deployment: +
Da es sich bei Microservices um unabhängige Einheiten handelt, ist es relativ einfach, neue Versionen einzelner Microservices zu deployen, ohne den Rest des Systems zu beeinträchtigen
* Lose Kopplung: +
Das Konzept von Microservices ermöglicht eine lose Kopplung zwischen abhängigen Services. Beispielsweise kann sich ein von Service A benötigter Service B innerhalb eines Clusters von gleichwertigen Service B-Instanzen befinden. Service A benötigt keine direkte Kopplung zu einer Service B-Instanz, sondern sendet seine Requests an eine vordefinierte URL. Der Cluster Controller nimmt den Request entgegen, leitet ihn an eine beliebige Service B-Instanz weiter und Letztere verarbeitet den Request und retourniert eine Response.
* Testing: +
Aufgrund der klaren Abgrenzung und losen Kopplung zu anderen Services lassen sich einzelne Microservices einfach testen. Die bestehenden Abhängigkeiten können mittels geringem Aufwand durch entsprechende Mocks ersetzt werden.
* Parallele Entwicklung: +
Aufgrund der klaren funktionalen Abgrenzung und Unabhängigkeit eines Microservices ist es möglich, pendente Entwicklungsarbeiten an mehreren Microservices zu parallelisieren (z.B. indem unterschiedliche Entwicklungsteams an unterschiedlichen Services arbeiten)

__Nachteile:__

* Komplexität: +
Der Aufbau und die Pflege eines Systems, welches aus vielen kleinen, unabhängigen Microservices besteht, kann relativ schnell an Komplexität zunehmen
* Kommunikation zwischen den Services: +
Die Kommunikation zwischen einzelnen Microservices ist komplexer als die Kommunikation innerhalb eines Monoliths. Zudem haben externe Einflüsse wie beispielsweise die Netzwerkverbindung (Latenzzeit, Bandbreite, Auslastung, Durchsatz) einen Einfluss auf die Qualität und Geschwindigkeit der Kommunikation

**A3) Self-contained systems (SCS)**

__Vorteile:__

* Einfachheit: +
SCS sind relativ einfach zu verstehen (verglichen mit verteilten Systemen)
* Erweiterbarkeit: +
Etwaige Modifikationen oder Erweiterungen innerhalb eines SCS sind mit geringer Komplexität realisierbar, da sich die darin befindlichen Funktionalitäten nur in dem jeweils betroffenen SCS befinden und nicht über mehrere Systeme aufgetrennt sind 
* Parallele Entwicklung: +
Aufgrund der klaren funktionalen Abgrenzung und Unabhängigkeit eines SCS ist es möglich, pendente Entwicklungsarbeiten an mehreren SCS zu parallelisieren (z.B. indem unterschiedliche Entwicklungsteams an unterschiedlichen SCS arbeiten)

__Nachteile:__

* Begrenzte Skalierbarkeit: +
Es kann schwierig sein, ein SCS horizontal zu skalieren, da das System jeweils als atomare Einheit deployed werden muss
* Begrenzte Wiederverwendbarkeit: +
SCS sind unabhängige Funktionseinheiten, besitzen jedoch meist einen eigenen Stack aus Frontend, Businesslogik und Persistenz. Daher ist die funktionale Wiederverwendung eines SCS eingeschränkter als bei einzelnen Microservices. Mittels dem Einsatz spezifischer Kommunikationsmechanismen (z.B. API, Event-driven) ist es jedoch möglich, Funktionalitäten eines SCS zur Wiederverwendung bereitzustellen.

**A4) Lambda architecture**

__Vorteile:__

* Skalierbarkeit: +
Lambda-Funktionen können automatisch skaliert werden, um der aktuellen Nachfrage gerecht zu werden
* Kosteneffizienz: +
Bei einer Mehrheit der aktuellen Hyperscaler zahlt man nur für die verbrauchte Rechenzeit, was - vor allem bei fluktuierender Auslastung - kostengünstiger sein kann als der Betrieb eigener Server
* Echtzeitverarbeitung: +
Die Echtzeitverarbeitungskomponente (Stream / Speed Layer) der Lambda-Architektur ermöglicht die sofortige Verarbeitung und Analyse der eingehenden Daten
* Datenverarbeitung: Separation of Concerns: +
Durch die Aufteilung der Datenverarbeitung in einen Stream und Batch Layer lassen sich die jeweiligen Systemverantwortlichkeiten und Funktionalitäten sauber voneinander separarieren

__Nachteile:__

* Komplexität: +
Die grundsätzliche Implementierung einer Lambda-Architektur kann relativ schnell komplex werden, da zwei separate Layer / Systeme für die Datenverarbeitung erforderlich sind (Stream & Batch Layer).
* Infrastruktur- / Vendor-basiert: +
Die Implementierung einer Lambda-Architektur auf Basis von Open Source-Technologien gefolgt von einem Cloud-Deployment kann zu komplexen Fehlersituationen führen, weshalb meist auf angebotene Services der jeweiligen Hyperscaler (Microsoft, Amazon, Google) zurückgegriffen wird. Dabei erhöht man jedoch das Risiko eines Vendor Lock-ins bzw. die Abhängigkeit zum verwendeten Hyperscaler / Vendor.

|**Entscheidung**|A2) Microservices
|**Begründung**|Der Einsatz von Microservices deckt die erhöhte Priorität betreffend den Punkten Wiederverwendbarkeit, Modifizierbarkeit / Erweiterbarkeit und Skalierbarkeit optimal ab. +
Funktionalitäten können optimal auf einzelne Services aufgeteilt und Letztere mit möglichst loser Kopplung entwickelt, betrieben und gewartet werden. Des Weiteren können einzelne Services je nach anfallender Last dynamisch / automatisiert skaliert werden.
|**Follow-up Entscheidungen**|-
|===

[cols="2,6"]
|===
|**ID**|ADR-BAC-20
|**Anliegen (Concern)**|Welcher Architekturstil soll grundlegend innerhalb einer deploybaren Einheit eingesetzt werden?
|**Kontext**
a|Diese Entscheidung befasst sich damit, welcher Architekturstil grundlegend für die interne Struktur (Mikroarchitektur) der einzelnen Backend-Komponenten eingesetzt werden soll. +
Hierbei handelt es sich jedoch nur um den grundlegend zu verwendenden Stil - es ist durchaus legitim und plausibel, dass es aus Sicht einer oder mehrerer Komponenten sinnvoller ist, eine andere interne Struktur zu wählen. Der Einsatz eines komponentenspezifischen Stils sollte jedoch in einem dedizierten ADR konkret begründet werden.
|**Alternativen**
a|
**A1) Layered architecture**

__Vorteile:__

* Separation of Concerns: +
Durch die einzelnen Layers wird eine klare Separation of Concerns geschaffen, was die Verständlichkeit des Codes erhöht
* Wiederverwendbarkeit: +
Da jede Schicht unabhängig entwickelt und getestet werden kann, wird die Wiederverwendbarkeit indirekt erhöht
* Innerhalb eines Layers ist es relativ einfach, bestehende Funktionen zu ändern oder neue hinzuzufügen, ohne den Rest der Anwendung zu beeinträchtigen
* Testing: +
Die einzelnen Layer können isoliert sehr gut getestet werden

__Nachteile:__

* Modifizierbarkeit / Erweiterbarkeit: +
Starre Abhängigkeiten zwischen den einzelnen Layer können zu einer Gesamtstruktur führen, die unflexibel und nur schwer zu modifizieren / erweitern ist
* Hohe Kopplung durch https://devopedia.org/leaky-abstractions[leaky abstraction]: +
Wenn ein Layer seine Implementationsdetails nicht vollständig abstrahiert und abhängige Layer nicht korrekt ohne Kenntnis dieser Details kommunizieren können, wird von einer __leaky abstraction__ gesprochen. Dieser Effekt verletzt die Seperation of Concerns und erhöht somit die Kopplung zwischen den betroffenen Layers.

**A2) Hexagonal architecture (Ports & Adapters)**

__Vorteile:__

* Separation of Concerns: +
Durch die gezielte Trennung der Businesslogik und des "Ports & Adapter-Hexagons" wird eine klare Separation of Concerns geschaffen, was die Verständlichkeit des Codes erhöht
* Testbarkeit: +
Durch die einfache Abstraktion der externen Abhängigkeiten kann die interne Businesslogik einfacher und gezielter getestet werden
* Flexibilität: +
Die Möglichkeit, zwischen verschiedenen Technologien / Adaptern zu wechseln, macht diesen Stil zu einer flexiblen "Plugin-Architektur". Solange derselbe Port für unterschiedliche Adapter verwendet werden kann, können die konkreten Implementierungen ausgetauscht werden, ohne dabei Änderungen in der Businesslogik vorzunehmen.
* Modifizierbarkeit / Erweiterbarkeit: +
Aufgrund der abstrakten Ports kann die Businesslogik ohne Auswirkungen auf die externen Abhängigkeiten geändert werden. Änderungen innerhalb einer externen Abhängigkeit können lediglich mit der entsprechenden Änderung des jeweiligen Adapters nachgeführt werden, ohne die Businesslogik zu beeinflussen. +
Die Erweiterbarkeit ist ebenfalls gegeben, da neue Funktionen durch die Modifizierung der Businesslogik oder durch das Hinzufügen eines neuen Adapters hinzugefügt werden können.

__Nachteile:__

* Komplexität: +
Aufgrund der Trennung von Businesslogik und externen Abhängigkeiten und der diesbezüglich eingesetzten Indirektionen / Abstraktionen (z.B. durch den Einsatz von Interfaces) kann dieser Stil schwierig zu verstehen und daher komplexer und aufwändiger zu implementieren sein - vor allem für Entwickler, welche noch wenig / keine Erfahrung mit dem Stil besitzen

**A3) Clean / Onion architecture**

__Vorteile:__

* Kombination mit Hexagonal Architecture (Ports & Adapters) +
Die Schichten der Clean / Onion Architecture sorgen für eine konkrete Organisation der Businesslogik, dem Inneren des "Ports & Adapter-Hexagons"
* Verwendung von Domain-driven design (DDD) +
Clean / Onion Architecture baut auf einem gegebenen Domänenmodell auf und unterstützt daher die Verwendung von DDD inkl. dessen Layers (Domain, Application, Infrastructure, UI)
* Separation of Concerns: +
Durch die gezielte Trennung der Businesslogik in einzelne Layer wird eine klare Separation of Concerns geschaffen, was die Verständlichkeit des Codes erhöht
* Testbarkeit: +
Durch die einfache Abstraktion der Abhängigkeiten kann die interne Businesslogik eines Layers isoliert und daher einfacher / gezielter getestet werden
* Flexibilität: +
Aus Sicht eines inneren Layers (z.B. Domain) können die äusseren Layer (z.B. Application) problemlos ausgetauscht werden, ohne zu Änderungen im betroffenen Layer zu führen
* Modifizierbarkeit / Erweiterbarkeit: +
Durch die lose und gerichtete Kopplung (äussere Schichten "zeigen" nach innen, nie umgekehrt) lassen sich äussere Layer einfach und ohne grossen Mehraufwand modifizieren. Änderungen am Domain Layer (der "Kern" des Domänenmodells) hingegen dürfen zu abhängigen Anpassungen in den äusseren Layern führen, da sie alle (direkt oder indirekt) von der Domäne abhängig sind. +
Die Erweiterbarkeit ist ebenfalls gegeben, da neue Funktionen durch die Modifizierung der Businesslogik eines Layers hinzugefügt werden können.

__Nachteile:__

* Komplexität: +
Aufgrund der zahlreichen Layers und diesbezüglich eingesetzten Indirektionen / Abstraktionen (z.B. durch den Einsatz von Interfaces) kann dieser Stil schwierig zu verstehen und daher komplexer und aufwändiger zu implementieren sein - vor allem für Entwickler, welche noch wenig / keine Erfahrung mit dem Stil besitzen
* Umfangreiche Codebase / Boilerplate-Code: +
Die Verwendung von Layer-Abstraktionen und vordefinierten Mappings zwischen den Layern kann zu Boilerplate-Code und - darausfolgend - einer umfangreicheren Codebase führen

|**Entscheidung**|A2) Hexagonal architecture (Ports & Adapters)
|**Begründung**|Die Verwendung einer hexagonalen Mikroarchitektur (Ports & Adapters) deckt die erhöhte Priorität betreffend Modifizierbarkeit / Erweiterbarkeit optimal ab. +
Die Businesslogik wird mit definierten Abstraktionen (Ports) sauber von allen externen Abhängigkeiten (Adapters) separiert, was zu einer losen Kopplung führt. Für die innere Struktur der Businesslogik setzen wir nicht explizit auf Clean / Onion Architecture, da dieser Ansatz für unser Domänenmodell zu komplex wäre und daher over-engineered wäre.
|**Follow-up Entscheidungen**|-
|===

==== Persistenz

[cols="2,6"]
|===
|**ID**|ADR-BAC-30
|**Anliegen (Concern)**|Werden mehrere (unterschiedliche) Datenbanken für PhysioConnect eingesetzt?
|**Kontext**
a|PhysioConnect persistiert unterschiedlichste Daten zur Laufzeit. Beispielsweise werden einerseits stetig aufgezeichnete Messdaten des Patienten abgelegt, andererseits aber auch allgemeine Therapiedaten. Im Rahmen dieser Entscheidung soll analysiert werden, ob die Verwendung mehrerer (unterschiedlicher) Datenbanken für die Persistierung der Daten eingesetzt werden sollen.
|**Alternativen**
a|
**A1) Alle Daten in derselben Datenbank**

__Vorteile:__

* Die Verwaltung der Daten ist einfacher, da alles an einem zentralen Ort abgelegt ist.
* Die Datenkonsistenz kann einfacher gewährleistet werden.
** Ein eventuell benötigtes Transaktionsmanagement kann out-of-the-box über mehrere Tabellen verwendet werden.
* Die Verwendung einer einzelnen Datenbank kann kostengünstiger sein als die Verwendung mehrerer Datenbanken, insbesondere wenn man einen Cloud-basierten Datenbankdienst nutzt, welcher nach Verbrauch abrechnet.

__Nachteile:__

* Vor allem bei unterschiedlichen Speicherintervallen und verschiedenen, grossen Datenmengen kann die Datenbank sehr schnell an Komplexität gewinnen und an Performance verlieren. Beispielsweise könnten die Patienten-Messdaten im Sekundentakt eingehen und abgelegt werden, während die allgemeinen Therapiedaten vielleicht nur monatlich einmal aktualisiert werden.

**A2) Separate Datenbank für die Patienten-Messdaten**

__Vorteile:__

* Besser geeignet wenn Daten mit unterschiedlichen Speicher- und Verarbeitungsanforderungen abgelegt werden sollen. Bei Daten, welche unterschiedliche Speicher- oder Verarbeitungsfunktionen erfordern, kann es sinnvoll sein, diese in getrennten Datenbanken zu speichern. So können beispielsweise strukturierte Daten, auf die häufig zugegriffen wird, in einer relationalen Datenbank und grosse Mengen unstrukturierter Daten in einer NoSQL-Datenbank persistiert werden.
* Besser geeignet wenn Daten mit unterschiedlichen Sicherheitsanforderungen abgelegt werden sollen. Bei Daten, welche unterschiedliche Sicherheitsstufen erfordern, kann es sinnvoll sein, diese in getrennten Datenbanken zu speichern. So können beispielsweise sensible Patienten-Messdaten in einer separaten, eventuell verschlüsselten Datenbank persistiert werden, während Therapiedaten in einer "normalen" Datenbank abgelegt werden.
* Besser geeignet wenn man grosse Datenmengen verzeichnet. Eine diesbezügliche Verteilung der Datenmengen auf mehrere Datenbanken kann die Leistung und Skalierbarkeit des Gesamtsystems verbessern.
* Besser geeignet wenn man mehrere Anwendungen unterstützen soll, welche jeweils auf unterschiedliche Teilmengen von Daten zugreifen müssen.

__Nachteile:__

* Die Verwendung mehrerer Datenbanken (vor allem auch wenn sie nicht demselben Modell entsprechen) kann die Gesamtkomplexität des Systems (Implementation, Betrieb, Wartung) generell stark erhöhen.

|**Entscheidung**|A2) Separate Datenbank für die Patienten-Messdaten
|**Begründung**|Wir erachten es als sinnvoll, die eingehenden Patienten-Messdaten in einer separaten Datenbank zu persistieren, da sie einerseits andere Sicherheitsanforderungen als die herkömmlichen Therapiedaten erfüllen müssen (Stichwort Datenschutz / Privacy) und andererseits viel frequentierter abgelegt werden, was zu einer beachtlich grösseren Datenmenge führen wird.
|**Follow-up Entscheidungen**
a|
* **ADR-BAC-31** +
Welche Datenbankmodelle werden für PhysioConnect eingesetzt?

|===

[cols="2,6"]
|===
|**ID**|ADR-BAC-31
|**Anliegen (Concern)**|Welche Datenbankmodelle werden für PhysioConnect eingesetzt?
|**Kontext**
a|PhysioConnect persistiert unterschiedlichste Daten zur Laufzeit. Beispielsweise werden einerseits stetig aufgezeichnete Messdaten des Patienten abgelegt, andererseits aber auch allgemeine Therapiedaten. Im Rahmen dieser Entscheidung soll analysiert werden, welche Datenbankmodelle für die unterschiedlichen Datenarten und Anwendungsfälle von PhysioConnect passend sein könnten.
|**Alternativen**
a|
**A1) Relationale Datenbank**

__Verwendungszwecke:__

* Verwaltung von strukturierten Daten, welche einem vordefinierten, statischen Schema folgen
* Eignet sich für Anwendungen, welche ein hohes Mass an Datenintegrität erfordern, wie beispielsweise Finanz- oder Gesundheitssysteme 
* Durchführung komplexer Datenabfragen
* Definition von Datenbeschränkungen, um die Genauigkeit und Konsistenz der Daten zu gewährleisten

__Vorteile:__

* Strukturierte Daten: +
Relationale Datenbanken sind darauf ausgelegt, strukturierte Daten zu speichern, was die Suche und den Abruf bestimmter Daten mit SQL-Abfragen erleichtert.
* Datenintegrität: +
Relationale Datenbanken erzwingen Datenintegritätsbeschränkungen, was bedeutet, dass die Daten konsistent und genau gespeichert werden.
* Skalierbarkeit: +
Relationale Datenbanken sind in der Lage, grosse Datenmengen zu verarbeiten, und können bei wachsendem Umfang der Datenbank einfach skaliert werden.
* Sicherheit: +
Relationale Datenbanken bieten Sicherheitsfunktionen wie Benutzerauthentifizierung, Datenverschlüsselung und Zugriffskontrolle.

__Nachteile:__

* Komplexität: +
Relationale Datenbanken können aufwändig in der Einrichtung und Wartung sein, insbesondere bei grossen und komplexen Systemen.
* Performance: +
Relationale Datenbanken können bei der Verarbeitung grosser Datenmengen oder einer hohen Anzahl gleichzeitiger Benutzer Performanceprobleme aufweisen.
* Flexibilität: +
Relationale Datenbanken sind nicht so flexibel wie einige NoSQL-Datenbanken, was die Speicherung komplexer oder unstrukturierter Daten erschweren kann.
* Kosten: +
Relationale Datenbanken können im Vergleich zu einigen NoSQL-Datenbanken teurer in der Einrichtung und Wartung sein.

**A2) Objektorientierte Datenbank**

__Verwendungszwecke:__

* Verwaltung von komplexen Datenstrukturen, welche nicht in ein herkömmliches relationales Schema passen
* Integration in Anwendungen, welche objektorientierte Programmiersprachen wie Java und C++ verwenden
* Verwaltung grosser Datenmengen
* Eignet sich für Anwendungen, welche ein hohes Mass an Flexibilität und Anpassungsfähigkeit erfordern, wie beispielsweise Datenanalyse- oder maschinelle Lernsysteme

__Vorteile:__

* Datenmodellierung: +
Objektorientierte Datenbanken ermöglichen eine natürlichere und intuitivere Datenmodellierung mittels Verwendung von Objekten und Klassen.
* Datenintegrität: +
Objektorientierte Datenbanken erzwingen Datenintegritätsbeschränkungen und stellen so sicher, dass die Daten konsistent und korrekt gespeichert werden.
* Skalierbarkeit: +
Objektorientierte Datenbanken sind in der Lage, grosse Datenmengen zu verarbeiten und lassen sich leicht skalieren, wenn der Umfang der Datenbank wächst.
* Integration: +
Objektorientierte Datenbanken lassen sich leicht in objektorientierte Programmiersprachen wie Java oder C++ integrieren.

__Nachteile:__

* Komplexität: +
Objektorientierte Datenbanken können sehr komplex in der Einrichtung und Wartung sein, insbesondere bei grossen und komplexen Systemen.
* Performance: +
Bei objektorientierten Datenbanken kann es zu Performanceproblemen kommen, wenn grosse Datenmengen oder eine hohe Anzahl gleichzeitiger Benutzer verarbeitet werden.
* Kompatibilität: +
Objektorientierte Datenbanken sind möglicherweise nicht mit allen Anwendungen und Programmiersprachen kompatibel.
* Kosten: +
Die Einrichtung und Wartung objektorientierter Datenbanken kann im Vergleich zu einigen anderen Datenbankarten teurer sein.

**A3) Dokumentdatenbank**

__Verwendungszwecke:__

* Verwaltung unstrukturierter oder halbstrukturierter Daten, welche nicht gut in ein traditionelles relationales Schema passen
* Verwaltung grosser Datenmengen
* Eignet sich für Anwendungen, welche ein hohes Mass an Flexibilität und die Fähigkeit erfordern, Daten schnell und effizient zu speichern und abzurufen
* Eignet sich für Anwendungen, welche ein hohes Mass an Skalierbarkeit und die Fähigkeit erfordern, eine grosse Anzahl gleichzeitiger Benutzer zu verarbeiten

__Vorteile:__

* Flexibilität: +
Dokumentdatenbanken sind für die Speicherung unstrukturierter Daten konzipiert, was sie flexibler macht als relationale Datenbanken.
* Skalierbarkeit: +
Dokumentdatenbanken sind in der Lage, grosse Datenmengen zu verarbeiten und lassen sich leicht skalieren, wenn der Umfang der Datenbank wächst.
* Performance: +
Dokumentdatenbanken sind im Allgemeinen performanter und effizienter als relationale Datenbanken, wenn es um das Lesen und Schreiben von Daten geht.
* Benutzerfreundlichkeit: +
Dokumentdatenbanken sind im Vergleich zu relationalen Datenbanken oft einfacher einzurichten und zu pflegen - insbesondere für Entwickler, die mit dem JSON-Datenformat vertraut sind.

__Nachteile:__

* Datenmodellierung: +
Es kann schwieriger sein, Daten in einer Dokumentdatenbank zu modellieren als in einer relationalen Datenbank, insbesondere bei komplexen Datenstrukturen.
* Datenintegrität: +
In Dokumentdatenbanken werden Einschränkungen der Datenintegrität möglicherweise nicht so streng durchgesetzt wie in relationalen Datenbanken, was zu Dateninkonsistenzen führen kann.
* Kompatibilität: +
Dokumentdatenbanken sind möglicherweise nicht mit allen Anwendungen und Programmiersprachen kompatibel.
* Kosten: +
Die Einrichtung und Wartung von Dokumentdatenbanken kann im Vergleich zu anderen Datenbankmodellen teurer sein.

**A4) Graphdatenbank**

__Verwendungszwecke:__

* Verwaltung komplexer, miteinander verknüpfter Daten und deren Beziehungen untereinander
* Verwaltung grosser Mengen von Echtzeitdaten
* Eignet sich für Anwendungen, welche ein hohes Mass an Flexibilität und die Fähigkeit erfordern, Datenbeziehungen schnell und effizient abzufragen und zu analysieren
* Eignet sich für Anwendungen, welche ein hohes Mass an Skalierbarkeit und die Fähigkeit erfordern, eine grosse Anzahl gleichzeitiger Benutzer zu verarbeiten

__Vorteile:__

* Datenmodellierung: +
Graphdatenbanken eignen sich gut für die Speicherung komplexer, miteinander verbundener Daten und können Beziehungen zwischen Daten auf eine natürlichere und intuitivere Weise modellieren.
* Performance: +
Graphdatenbanken sind im Allgemeinen performanter als relationale Datenbanken, wenn es darum geht, Daten abzufragen und Muster in grossen, komplexen Datensätzen zu finden.
* Skalierbarkeit: +
Graphdatenbanken können grosse Datenmengen verarbeiten und lassen sich bei wachsendem Umfang der Datenbank einfach skalieren.
* Verarbeitung von Echtzeitdaten: +
Graphdatenbanken eignen sich gut für die Verarbeitung von Echtzeitdaten und können Daten schnell aktualisieren und abfragen, wenn sie sich ändern.

__Nachteile:__

* Komplexität: +
Die Einrichtung und Pflege von Graphdatenbanken kann komplex sein, insbesondere bei grossen und komplexen Systemen.
* Datenintegrität: +
Graphdatenbanken setzen Datenintegritätsbeschränkungen möglicherweise nicht so streng durch wie relationale Datenbanken, was zu Dateninkonsistenzen führen kann.
* Kompatibilität: +
Graphdatenbanken sind möglicherweise nicht mit allen Anwendungen und Programmiersprachen kompatibel.
* Kosten: +
Die Einrichtung und Wartung von Graphdatenbanken kann im Vergleich zu anderen Datenbankmodellen teurer sein.

**A5) Zeitreihendatenbank**

__Verwendungszwecke:__

* Verwaltung von Daten mit Zeitstempel wie z.B. Sensor-, Finanz- oder Protokolldaten
* Verwaltung grosser Datenmengen
* Eignet sich für Anwendungen, welche ein hohes Mass an Performance und die Fähigkeit zur schnellen und effizienten Abfrage und Analyse von zeitbasierten Daten erfordern
* Eignet sich für Anwendungen, welche ein hohes Mass an Skalierbarkeit und die Fähigkeit erfordern, eine grosse Anzahl gleichzeitiger Benutzer zu verarbeiten

__Vorteile:__

* Datenmodellierung: +
Zeitreihendatenbanken sind speziell für die Speicherung und Abfrage von Zeitstempeldaten konzipiert, was die Modellierung und Analyse von zeitbasierten Daten erleichtert.
* Performance: +
Zeitreihendatenbanken sind für schnelle Schreibvorgänge und effiziente Abfragen von Zeitstempeldaten optimiert.
* Skalierbarkeit: +
Zeitreihendatenbanken können grosse Datenmengen verarbeiten und lassen sich leicht skalieren, wenn die Grösse der Datenbank zunimmt.
* Datenkompression: +
Zeitreihendatenbanken können Datenkomprimierungstechniken verwenden, um die Grösse der Datenbank zu verringern und die Performance zu verbessern.

__Nachteile:__

* Komplexität: +
Die Einrichtung und Pflege von Zeitreihendatenbanken kann komplex sein, insbesondere bei grossen und komplexen Systemen.
* Kompatibilität: +
Zeitreihendatenbanken sind möglicherweise nicht mit allen Anwendungen und Programmiersprachen kompatibel.
* Kosten: +
Die Einrichtung und Pflege von Zeitreihendatenbanken kann im Vergleich zu anderen Datenbanktypen teurer sein.
* Begrenzte Datentypen: +
Zeitreihendatenbanken sind für die Speicherung und Abfrage von Zeitstempeldaten optimiert und unterstützen andere Datentypen möglicherweise nicht so effizient.

|**Entscheidung**
a|
Kombination aus

* A1) Relationale Datenbank oder A3) Dokumentdatenbank +
Für alle Daten ausser die Patienten-Messdaten
* A3) Dokumentdatenbank +
Für die Patienten-Messdaten

|**Begründung**|Für die Ablage aller Daten, welche nicht zu den Patienten-Messdaten gehören, sollte eine herkömmliche relationale Datenbank allen Anforderungen gerecht werden. Alternativ könnte eine Dokumentdatenbank ebenfalls passend eingesetzt werden. +
Für die Persistierung der Patienten-Messdaten sollte hingegen primär auf eine Dokumentdatenbank zurückgegriffen werden, da sie auf die Ablage halb- oder unstrukturierter Daten spezialisiert sind und eine hohe Performance bezüglich Schreib- und Lesevorgängen vorweisen können.
|**Follow-up Entscheidungen**|-
|===

==== Messaging

[cols="2,6"]
|===
|**ID**|ADR-MES-10
|**Anliegen (Concern)**|Wie wird das Backend-Messaging innerhalb von Physio Connect umgesetzt?
|**Kontext**
|Sowohl Requests von Physiotherapeuten als auch von Patienten werden vom PhysioConnect-Backend gehandhabt. Zu Peak-Zeiten kann es sich dabei um eine hohe Anzahl von Requests bzw. eine hohe eingehende Datenmenge handeln. Da das PhysioConnect-Backend gemäss Architekturentscheid __ADR-BAC-10__ aus mehreren Microservices bestehen wird, soll überprüft werden, ob eine Messaging-Komponente eingesetzt werden soll und falls ja, welche.
|**Alternativen**
a|

**A1) HTTP(S)**

__Vorteile:__

* Einfache Implementierung
* Know-How weit verbreitet
* Von vielen verschiedenen Libraries unterstützt

__Nachteile:__

* Weniger effizient als einige Alternativen

**A2) Message Queues**

(RabbitMQ, Kafka)

__Vorteile:__

* Kann je nach Implementierungsart Requests effizient abarbeiten (Trade-off mit Traceablility)
* Gruppierung zusammenhängender Messages nach Themen (Topics)
* Skalierbare Messaging-Komponente
* Sender muss nicht darauf warten, bis die Message verarbeitet wurde
* Bei Ausfall der Datenbank könnten die Daten kurzfristig in der Queue als Messages persistiert werden, bis die Datenbank wieder erreichbar ist

__Nachteile:__

* Benötigt Messaging Container
* Erhöht Komplexität der Lösung
* Know-How kann sehr punktuell sein

**A3) gRPC**

__Vorteile:__

* Sehr performant
* Ermöglicht bidirektionale Kommunikation

__Nachteile:__

* Mehraufwand für die Implementation
* Weniger breite Unterstützung als andere Ansätze
* Weniger Know-How vorhanden

|**Entscheidung**|A1) HTTP(S)
|**Begründung**
a|

* Kommunikation mit HTTP(S) hat die geringste Komplexität
* Time-to-Market ist in einem ersten Schritt wichtiger als die Performance
* Für eine geringe Anzahl Benutzer wird es einfach sein, eine gute Performance mittels Skalierung zu erreichen
* Es ist einfacher, Bottlenecks zu erkennen und zu optimieren, wenn das System bereits produktiv im Einsatz ist

Es soll jedoch bei Design und Implementation darauf geachtet werden, dass die Möglichkeit der zukünftig gezielten Verwendung von gRPC oder einer Message Queue erhalten bleibt.

|**Follow-up Entscheidungen**|-
|===
